import numpy as npimport matplotlib.pyplot as pltfrom PlanetProfile.Thermodynamics.HydroEOS import GetOceanEOS, GetPfreezeimport timeimport reaktoro as rktfrom reaktoroProps import SpeciesParserfrom PlanetProfile.Thermodynamics.Reaktoro.reaktoroProps import ices_phases_amount_moldef best_fit_line_plot(x, y, x_label, y_label, title):    '''    Plot data in scatterplot with best fit line    '''    slope, intercept = np.polyfit(x, y, 1)    best_fit_line = slope * x+ intercept    fig = plt.figure()    ax1 = fig.add_subplot(111)    ax1.scatter(x, y, color='blue', label='Data points')    ax1.plot(x, best_fit_line, color='red', label='Best fit line')    ax1.axhline(0, color='green', linestyle='--', label='No pressure difference')    ax1.set_xlabel(x_label)    ax1.set_ylabel(y_label)    ax1.set_title(title)def benchmark_with_gsw_version_two():    '''    Benchmark reaktoro with gsw and seafreeze to find freezing pressures for given array of bottom temperatures    '''    # Establish temperature range to find bottom pressures    temperature_range = np.linspace(263.15, 270.15, 8)    # Establish pressure limits to search over and the resolution    P_MPa = np.arange(0.01, 150, 0.05)    # Array that stores reaktoro bottom pressure results    rkt_bPressure_results = []    # Time how long reaktoro takes    start_time = time.time()    # Speciation ratio    speciation_ratio = "H+: 1e-16, OH-: 1e-16"    # REAKTORO RESULTS    # Go through each bottom temperature in range, obtaining the MeltEOS identically to how PlanetProfile does it (line 262-264 of SetupInit.py)    for temperature in temperature_range:        T_K = np.linspace(temperature - 0.01, temperature + 0.01, 11)        # Prescribe "CustomSolution", the name for PlanetProfile to use Reaktoro framework        meltEOS = GetOceanEOS("CustomSolution", 0, P_MPa, T_K,  'Vance2018', speciation_ratio,'Millero', 'Vance2018', 'lookup', FORCE_NEW=True)        rkt_bPressure_results.append(GetPfreeze(meltEOS, 1, temperature,                                           PLower_MPa=0.01, PUpper_MPa=150.01, PRes_MPa=1, UNDERPLATE=False))    rkt_time = time.time()    # GSW RESULTS    # Identical process to above but instead use GSW framework    gsw_bPressure_results = []    for temperature in temperature_range:        T_K = np.linspace(temperature-0.01, temperature+0.01, 11)        meltEOS = GetOceanEOS("Seawater", 0, P_MPa, T_K, 'Vance2018', 'Millero', 'Vance2018', 'lookup', FORCE_NEW=True)        gsw_bPressure_results.append(GetPfreeze(meltEOS, 1, temperature,                                           PLower_MPa=0.01, PUpper_MPa=150.01, PRes_MPa=1, UNDERPLATE=False))    gsw_time = time.time()    # Print run times    print("RKT Runtime: ", rkt_time-start_time)    print("GSW Runtime: ", gsw_time-rkt_time)    # Convert lists into numpy arrays so they can be subtracted    rkt_bPressure_results = np.array(rkt_bPressure_results)    gsw_bPressure_results = np.array(gsw_bPressure_results)    # Find pressure difference between reaktoro and gsw    pressure_difference_results = rkt_bPressure_results-gsw_bPressure_results    # Graph the difference in pressure difference as a function of    x_label = 'Bottom temperature (K)'    y_label = 'Reaktoro bottom pressure - GSW bottom pressure (MPa)'    title = 'Difference in bottom pressure between Reaktoro and GSW for Pure water'    best_fit_line_plot(temperature_range, pressure_difference_results, x_label, y_label, title)    # Print pressure difference results    print(pressure_difference_results)    print("--------------------")    print(f"Average pressure difference: {np.average(abs(pressure_difference_results))}")    print("--------------------")    plt.show()def species_rkt_check():    # Speciation ratio    speciation_ratio = "H+: 0, OH-: 0, Cl-: 0.5657647, Na+: 0.4860597, Mg+2: 0.0547421, Ca+2: 0.0106568, K+: 0.0105797, SO4-2: 0.0292643"    aqueous_species_string, speciation_ratio_mol_kg = SpeciesParser(speciation_ratio)    P_MPa = np.linspace(0.1, 150, 10)    T_K = np.linspace (268, 278, 2)    rkt_bottom_pressure = species_amount_check(aqueous_species_string, speciation_ratio_mol_kg, P_MPa, T_K)    gsw_bPressure_results = []    for temperature in T_K:        T_K = np.linspace(temperature-0.01, temperature+0.01, 11)        meltEOS = GetOceanEOS("Seawater", 35.155, P_MPa, T_K, 'Vance2018', 'Millero', 'Vance2018', 'lookup')        gsw_bPressure_results.append(GetPfreeze(meltEOS, 1, temperature,                                           PLower_MPa=0.01, PUpper_MPa=150.01, PRes_MPa=1, UNDERPLATE=False))    difference_results = rkt_bottom_pressure-gsw_bPressure_resultsdef species_amount_check(aqueous_species_list, speciation_ratio_mol_kg, P_MPa, T_K, significant_threshold = 1e-14):    """     Calculates whether ice is freezing at the given temperature and pressure. Utilizes the reaktoro framework to     constrain the equilibrium position at the prescribed pressure and temperature with the given composition,     and determines if ice has formed at a significant threshold of 1e-14, therefore calculating the phase of the solution     and returning true if the phase is ice and false if the phase is liquid.     Parameters     ----------     aqueous_species_list: aqueous species in reaction. Should be formatted in one long string with a space in between each species     speciation_ratio_mol_kg: the ratio of species in the aqueous solution in mol/kg of water. Should be a dictionary     with the species as the key and its ratio as its value.     P_MPa (float, shape N): the desired equilibrium freezing pressure(s) in an array of size N.     T_K (float, shape N): the desired equilibrium freezing temperature(s) in an array of size N.     significant_threshold: the amount of moles of ice present for H2O to be considered in solid phase. Default is 1e-14 moles.     Returns     -------     ice_present (boolean, shape N): an array of true and falses that indicate whether for prescribed P_MPa and T_K coordiantes        if there is ice present at significant threshold (default of 1e-14)     """    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    bottom_pressure = []    # Go through each (P,T) combination, where we assume that P_MPa and T_K are same size and correspond to one another    for i in range(np.size(T_K)):        T = T_K[i]        # Obtain the corresponding database (either frezchem or core10, depending on the temperature)        database = ""        ice_name = ""        if 200 < T and T < 298.15:            database = "frezchem.dat"  # Frezchem is compatible from 200 to 298.15K            ice_name = "Ice(s)"        else:            database = "core10.dat"            ice_name = "Ice"        # Create list that holds boolean values of whether ice is present        ice_present = []        for i in range(np.size(P_MPa)):            P = P_MPa[i]            # Initialize the database            db = rkt.PhreeqcDatabase(database)            # Prescribe the solution            solution = rkt.AqueousPhase(aqueous_species_list)            # Obtain all related solid phases            solids = rkt.MineralPhases()            # Initialize the system            system = rkt.ChemicalSystem(db, solution, solids)            # Create constraints on equilibrium - pressure and temperature            specs = rkt.EquilibriumSpecs(system)            specs.pressure()            specs.temperature()            # Create a solver object            solver = rkt.EquilibriumSolver(specs)            # Create a chemical state and its associated properties            state = rkt.ChemicalState(system)            conditions = rkt.EquilibriumConditions(specs)            conditions.pressure(P, "MPa")            conditions.temperature(T, "K")            restrictions = rkt.EquilibriumRestrictions(system)            difference_ion_amount = {}            # Populate the state with the prescribed species at the given ratios            for ion, ratio in speciation_ratio_mol_kg.items():                state.add(ion, ratio, "mol")                difference_ion_amount[ion] = ratio                if not "H2O" in ion:                    restrictions.cannotReact(ion)            for indexCannotReact in restrictions.speciesCannotDecrease():                print(system.species(indexCannotReact).name())            difference_ion_amount['Gypsum'] = state.speciesAmount('Gypsum')            props = rkt.ChemicalProps(state)            aqueous_index = system.phases().find("AqueousPhase")            # Solve the equilibrium problem            result = solver.solve(state, conditions)            # Update the properties            props.update(state)            # Check if the equilibrium problem succeeded            if result.succeeded():                # If so, obtain the total amount of solid H2O at equilibrium in moles                ice_amount = props.speciesAmount(ice_name)                # If the amount of solid H2O at equilibrium is > the significant threshold, then append true to the list, otherwise append false                ice_present.append(ice_amount > significant_threshold)                for ion in speciation_ratio_mol_kg.keys():                    difference_ion_amount[ion] -= float(props.speciesAmount(ion))                aprops = rkt.AqueousProps(state)                difference_ion_amount['Gypsum'] -= state.speciesAmount('Gypsum')                pH = aprops.pH()                # Reset the state                state = rkt.ChemicalState(system)            # Otherwise, the equilibrium problem failed so we need to handle it accordingly            else:                print(f"error at {T} K and {P} MPa")                # Reset the state                state = rkt.ChemicalState(system)        bottom_pressure.append(phase_change_results(ice_present, P_MPa))    # Convert the ice_present list into an array (of shape N) and return    return bottom_pressuredef phase_change_results(ice_present_array, associated_range):    '''    Linear search algorithm that searches the ice_present_array to find the two relevant indexes at which ice changes from not being present to being present, and then returns the associated average value of the two indices from the range.    and returns the average    Args:        ice_present_array: array of true/false values for ice being present or not        associated_range: the associated range that was used to determine the ice_present_array    Returns:        the associated average value of when ice goes from not being present to being present    '''    # Linear search (can be optimized in the future)    # Under the assumption that the pressure at which phase changes from liquid to ice occurs only once in list (i.e. list switches from false to true at most once)    for i in range(len(ice_present_array) - 1):        # If there is a change in phase between the ith index and ith+1 index, then return the average of the two        # from the corresponding range        if ice_present_array[i + 1] != ice_present_array[i]:            return (associated_range[i + 1] + associated_range[i]) / 2    # EDGE CASES: if there is not a change in phase, then either the ice is always present no matter the pressure or it    # is never present    if ice_present_array[0]:        # If the array is entirely true (meaning ice is always present), then return the upper limit of range (i.e.        # max pressure or max temperature)        return max(associated_range)    else:        # Otherwise the array is entirely false, so return the lower limit of range        return min(associated_range)if __name__ == "__main__":    # Call benchmark method    benchmark_with_gsw_version_two()