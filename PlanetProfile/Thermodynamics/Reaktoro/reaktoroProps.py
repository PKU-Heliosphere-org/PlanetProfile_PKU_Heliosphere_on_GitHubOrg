import copyimport reaktoro as rktimport numpy as npimport loggingfrom PlanetProfile.Utilities.defineStructs import Constantsfrom PlanetProfile.Utilities.DataManip import ResetNearestExtrapfrom scipy.interpolate import BSpline, splrepfrom PlanetProfile.Thermodynamics.Reaktoro.sigmaElectricMcCleskey2012 import elecCondMcCleskey2012from PlanetProfile.Thermodynamics.Reaktoro.reaktoroPropsHelperFunctions import *# Assign loggerlog = logging.getLogger('PlanetProfile')# Obtain correction spline (MUST COME LAST SO SPLINE GENERATOR CAN CALL SOME OF THE ABOVE FUNCTIONS)temperature_correction_spline = TemperatureCorrectionSplineGenerator()def ConstraintFinder(P_MPa, T_K, aqueous_species_list, speciation_ratio_mol_kg):    """ Finds the constraints of pressure and temperature that are compatible with both phreeqc and supcrt databases for the given solution speciation.        Namely, the temperature lower limit will be set by supcrt as equilibrium for this database can only be found starting at temperature of ~240K.        Moreover, the upper pressure limit will be set to 200MPa since Reaktoro doesn't have any high pressure ices.        As of now, the temperature upper limit and pressure lower limit are not adjusted, since Reaktoro seems to be compatible with high temperatures and low pressures of        PlanetProfile so no need to adjust.        Returns adjusted pressure and temperature ranges with the found constraints. This approach is similar to MgSO4 solution, however we take advantage        of RKt's dynamic ability to find chemical equilibrium different depending on the solution, rather than hard coding in constraints.    Args:        P_MPa (shape N): Array of pressures that will be queried over in future functions, but needs to be checked to ensure the pressures are within ranges compatible with Rkt.        T_K (shape M): Array of temperatures that will be queried over in future functions, but needs to be checked to ensure the temperatures are within ranges compatible with Rkt.        aqueous_species_list: String that has all species names that should be considered in aqueous phase        speciation_ratio_mol_kg: Dictionary of active species and the values of their molar ratio (mol/kg of water)    Returns:        P_MPa (AT MOST shape N): Adjusted array that only has values from initial P_MPa that are compatible with RKt.        P (AT MOST shape M): Adjusted array that only has values from initial T_K that are compatible with RKt.    """    # Save the lower limit of pressure of the pressure range, which will not be adjusted since Rkt is compatible to 0.1 MPa    P_lower_MPa = P_MPa[0]    # Save the upper limit of temperature of the temperature range, which will not be adjusted since core10 and supcrt are compatible well beyond range utilized by PP    T_upper_K = T_K[np.size(T_K) - 1]    # Save the initial upper limit of pressure of the pressure range    P_initial_upper_MPa = P_MPa[np.size(P_MPa) - 1]    # If the initial upper limit is above 200 MPa (the minimum for high pressure ices), then reset to 200 since we know Rkt doesn't have high pressure ices    if  P_initial_upper_MPa > Constants.PminHPices_MPa:        P_initial_upper_MPa = Constants.PminHPices_MPa    P_new_upper_MPa = P_initial_upper_MPa    # Save the initial lower limit of temperature of the temperature range, which may be adjusted since supcrt can only go to about ~240K depending on solution    T_initial_lower_K = T_K[0]    # If the initial lower limit is below Constants.TminRkt_K (240K) then reset to that value since we know supcrt can't go below this temperature    if T_initial_lower_K < Constants.TminRkt_K:        T_initial_lower_K = Constants.TminRkt_K    # Find the new lower temperature limit, which may be above 240K    T_new_lower_K = temperature_constraint(T_initial_lower_K, aqueous_species_list, speciation_ratio_mol_kg, "supcrt16")    # Adjust the pressure and temperature ranges with the new constraints    newP_MPa, newT_K = ResetNearestExtrap(P_MPa, T_K, P_lower_MPa, P_new_upper_MPa,                                          T_new_lower_K, T_upper_K)    # If the pressure and/or temperature ranges were adjusted, then log that they were changed to the user    if (not np.all(newP_MPa == P_MPa)) or (not np.all(newT_K == T_K)):        log.warning(f'Input EOS P and/or T of [Pmin, Pmax] = {P_lower_MPa}, {P_MPa[np.size(P_MPa) - 1]} MPa and [Tmin, Tmax] = {T_K[0]}, {T_upper_K}\n' +                    'extended beyond the Rkt compatibility limits, which will be adjusted to a compatible range of\n' +                    f'[Pmin, Pmax] = {P_lower_MPa}, {P_new_upper_MPa} MPa and [Tmin, Tmax] = {T_new_lower_K}, {T_upper_K} K.')    # Save only the unique values in the array and return    P_MPa = np.unique(newP_MPa)    T_K = np.unique(newT_K)    return P_MPa, T_Kdef RktProps(aqueous_species_list, speciation_ratio_mol_kg, P_MPa, T_K, database = "supcrt16"):    """ Determine density rho, heat capacity Cp, thermal expansivity alpha,        and thermal conductivity kTherm as functions of pressure P and        temperature T for the provided solution species list and corresponding molarity ratios.        Implements Reaktoro Supcrt database to find these thermal properties at equilibrium for the prescribed pressure and temperature.        Importantly, if any thermal properties cannot be found due to equilibrium divergence, we perform a 2d linear interpolation on these values, however        this outcome is HIGHLY UNLIKELY since we have found constraints that are compatible with Rkt, and user is warned if this does occur.    Args:        aqueous_species_string: String that has all species names that should be considered in aqueous phase        speciation_ratio_mol_kg: Dictionary of active species and the values of their molar ratio (mol/kg of water)        P_MPa (float, shape N): Pressures in MPa        T_K (float, shape M): Temperature in K        Returns:            rho_kgm3 (float, shape NxM): Mass density of liquid in kg/m^3            Cp_JkgK (float, shape NxM): Isobaric heat capacity of liquid in J/(kg K)            alpha_pK (float, shape NxM): Thermal expansivity of liquid in 1/K            kTherm_WmK (float, shape NxM): Thermal conductivity of liquid in W/(m K)    """    # Convert H2O label to H2O(aq) label for compatability with Supcrt database    aqueous_species_list, speciation_ratio_mol_kg = species_convertor_compatible_with_supcrt(aqueous_species_list, speciation_ratio_mol_kg)    # Create lists of thermodynamic properties that will be of length NxM    rho_kgm3 = []    Cp_JKgK = []    alpha_pK = []    kTherm_WmK = []    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    # Create Reaktoro objects    db, system, state, conditions, solver, props = SupcrtGenerator(aqueous_species_list, speciation_ratio_mol_kg, database)    # Create P_MPa and T_K into a meshgrid, which will improve runtime while iterating over the combinations    P_MPa, T_K = np.meshgrid(P_MPa, T_K, indexing='ij')    # Create a nditer iterator    it = np.nditer([P_MPa, T_K], flags =['multi_index'])    # Go through each P, T combination    for P, T in it:        P = float(P)        T = float(T)        conditions.temperature(T, "K")        #Establish equilibrium pressure constraint value        conditions.pressure(P, "MPa")        # Solve the equilibrium problem        result = solver.solve(state, conditions)        # Update the properties        props.update(state)        # Check if the equilibrium problem succeeded        if result.succeeded():            # If it did succeed, obtain the relevant aqueous only phase props            aqueous_props = props.phaseProps("AqueousPhase")            # Obtain the thermodynamic properties of the aqueous phase            rho_kg_m3 = aqueous_props.density()            Cp_J_kg_K = aqueous_props.specificHeatCapacityConstP()            # To calculate thermal coefficient, we will multiply inverse of specific volume by its            # partial derivative with respect to temperature            specific_volume_m3_kg = aqueous_props.specificVolume()            dSpecificVolumedT = aqueous_props.specificVolumeT()            thermalExpansivity_1_K = 1 / float(specific_volume_m3_kg) * float(dSpecificVolumedT)            # Append the values to the associated array            rho_kgm3.append(float(rho_kg_m3))            Cp_JKgK.append(float(Cp_J_kg_K))            alpha_pK.append(thermalExpansivity_1_K)            # Reset the state            state = reset_state(system, speciation_ratio_mol_kg)        # Otherwise, the equilibrium problem failed so we need to handle it accordingly        # THIS IS VERY UNLIKELY SINCE WE HAVE ESTABLISHED CONSTRAINTS OF TEMPERATURE AND PRESSURE THAT SHOULD WORK WITH SUPCRT        else:            # Log to the user that the computation was unsuccessful and that missed value will be extrapolated            log.warning(                f"Unsuccessful computation at: {props.pressure() / 1e+6} MPa and {props.temperature()} K.\n"                f"The temperature and pressure may be out of bounds, thus we will linearly extrapolate this value from previous ones using a 2d interopolation")            # Reset the state            state = reset_state(system, speciation_ratio_mol_kg)            # Append zeros, which will be modified later            rho_kgm3.append(0.0)            Cp_JKgK.append(0.0)            alpha_pK.append(0.0)    # Turn the list into an array of shape NxM    rho_kgm3 = np.array(rho_kgm3).reshape(P_MPa.shape)    Cp_JKgK = np.array(Cp_JKgK).reshape(P_MPa.shape)    alpha_pK = np.array(alpha_pK).reshape(P_MPa.shape)    # Thermal conductivity not provided by RKT, for now return constant thermal conductivity of water    kTherm_WmK = np.zeros_like(alpha_pK) + Constants.kThermWater_WmK    # In the case that any properties could not be calculated, we must linearly interpolate this    # THIS IS HIGHLY UNLIKELY SINCE WE HAVE FOUND CONSTRAINTS COMPATIBLE WITH RKT, BUT JUST IN CASE THIS IS IMPLEMENTED (has not been rigorously tested)    zero_indices = np.argwhere(rho_kgm3 == 0)    if np.size(zero_indices) != 0:        rho_kgm3, Cp_JKgK, alpha_pK = interpolation_2d(zero_indices, rho_kgm3, Cp_JKgK, alpha_pK)    # Return the thermodynamic properties    return rho_kgm3, Cp_JKgK, alpha_pK, kTherm_WmKclass RktPhase:    """    Class that can find the phase of a given speciation over a range of temperatures and pressures    """    def __init__(self, aqueous_species_list, speciation_ratio_mol_kg, TMin_K, TMax_K, PMin_MPa, PMax_MPa):        """        Initialize the RKtPhase() object with the minimum and maximum T (in K) and P (in MPa) and speciation info.        Importantly, find the associated freezing temperature at PMax_MPa, which will be used if any input pressure is >= PMax_MPa, since        Rkt won't be able to solve that problem.        """        self.aqueous_species_list = aqueous_species_list        self.speciation_ratio_mol_kg = speciation_ratio_mol_kg        self.TMin_K = TMin_K        self.TMax_K = TMax_K        self.PMin_MPa = PMin_MPa        # Create both frezchem and core Reaktoro systems that can be utilized later on        self.frezchem = PhreeqcGeneratorForChemicalConstraint(self.aqueous_species_list, self.speciation_ratio_mol_kg, "frezchem_new2.dat")        self.spline_for_pressures_above_100_MPa, self.PMax_MPa = Frezchem_Spline_Generator(self.aqueous_species_list, self.speciation_ratio_mol_kg)        self.calculated_freezing_temperatures = {}    def __call__(self, P_MPa, T_K, grid = False):        """        Call the ice_freezing function for the given input P_MPa and T_K coordinates.        Importantly, ice_frrezing assumes P_MPa and T_K are the same size and correspond to one another (coordinate pairs),        so we get them into that format if they are not already.        Args:            P_MPa: Array of pressures            T_K: Array of temperatures            grid: Whether or not they need to be made into a coordinate grid        Returns:            The associated phases of the solution for the input pressure and temperatures        """        if not grid:            np.array(P_MPa)            np.array(T_K)        freezing_temperatures = rkt_t_freeze(self.aqueous_species_list, self.speciation_ratio_mol_kg, P_MPa, self.frezchem, self.PMax_MPa, self.spline_for_pressures_above_100_MPa, self.calculated_freezing_temperatures)        if grid:            freezing_temperatures, T_K = np.meshgrid(freezing_temperatures, T_K, indexing='ij')        return (T_K < freezing_temperatures).astype(np.int_)        # Similar approach to SF, where we specify the P_MPa and T_K at equilibrium, and ice_freezing function returns        '''        # if ice has formed or not at given temperature and pressure, with 1 indicating the phase is solid and 0 indicating the phase is liquid        return ice_freezing(self.aqueous_species_list, self.speciation_ratio_mol_kg, P_MPa, T_K, self.PMax_MPa, self.TMin_K, self.TMax_K, self.spline_for_pressures_above_100_MPa, self.frezchem, self.core).astype(np.int_)        # Alternative used approaches that did not work are listed below (CAN BE DELETED IN FUTURE)        '''        '''        # IDENTICAL APPROACH TO GSW        # 1. Subtract the freezing temperature from the input temperature        # 2. Compare to zero -- if we are below the freezing temp, it's ice I, above, liquid        # 3. Cast the above comparison (True if less than Tfreeze, False if greater) to int,        #       so that we get 1 if we are below the freezing temp and 0 if above.        return (T_K - rkt_t_freeze(self.aqueous_species_list, self.speciation_ratio_mol_kg, P_MPa, self.TMin_K,                            self.TMax_K) < 0).astype(np.int_)        Alternative approach is to obtain Pfreezing from the prescribed T_K, since the way PlanetProfile obtains the Melting EOS,        this class will not have access to the hydrosphere TMin and TMax which I am using to constrain Reaktoro's search.        Instead, can use the constraints of         PMin to PMax to find the freezing pressure for a prescribed temperature via Reaktoro.        return (P_MPa - rkt_p_freeze(self.aqueous_species_list, self.speciation_ratio_mol_kg, T_K, self.PMin_MPa,                            self.PMax_MPa) < 0).astype(np.int_)        '''def rkt_t_freeze(aqueous_species_list, speciation_ratio_mol_kg, P_MPa, frezchem, PMax_MPa, freezing_temperature_spline, calculated_freezing_temperatures, TMin_K = 250, TMax_K = 300, significant_threshold = 0.1):    """     Calculates the temperature at which the prescribed aqueous solution freezes. Utilizes the reaktoro framework to     constrain the equilibrium position at the prescribed pressure, the lower and upper limits of temperature (in K),     and the total amount of ice at a significant threshold of 1e-14, therefore calculating and returning the     temperature (within the range) at which ice begins to form.     Parameters     ----------     aqueous_species_list: aqueous species in reaction. Should be formatted in one long string with a space in between each species     speciation_ratio_mol_kg: the ratio of species in the aqueous solution in mol/kg of water. Should be a dictionary     with the species as the key and its ratio as its value.     P_MPa: the desired equilibrium freezing pressure(s).     TMin_K: the lower limit of temperature that Reaktoro should query over     TMax_K: the upper limit of temperature that Reaktoro should query over     database: the Phreeqc database to be using in this calculation (either frezchem.dat or core10.dat)     significant_threshold: the amount of moles of ice present for H2O to be considered in solid phase. Default is 1e-14 moles.     Returns     -------     t_freezing_K: the temperature at which the solution begins to freeze.     """    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    # rkt.Warnings.disable(906)    # Create list that holds boolean values of whether ice is present    freezing_temperatures = []    db, system, state, conditions, solver, props = frezchem    state = rkt.ChemicalState(state)    # Create an iterator to go through P_MPa    it = np.nditer([P_MPa])    conditions.set("IP", significant_threshold)    conditions.setLowerBoundTemperature(TMin_K, "K")    conditions.setUpperBoundTemperature(TMax_K, "K")    for P in it:        P = float(P)        # Adjust Pressure        if P in calculated_freezing_temperatures.keys():            equilibrium_temperature = calculated_freezing_temperatures[P]            freezing_temperatures.append(equilibrium_temperature)            continue        # Check that pressure is below PMax_MPa, the maximum pressure constraint calculated previously        if P <= PMax_MPa:            # Specify equilibrium constraints            conditions.pressure(P, "MPa")            # Solve the equilibrium problem            result = solver.solve(state, conditions)            # Update the properties            props.update(state)            # Obtain the equilibrium temperature            equilibrium_temperature = props.temperature()            # Correct the equilibrium temperature using the temperature correction spline            equilibrium_temperature = equilibrium_temperature + temperature_correction_spline(P)            # Check if the result succeeded            if result.succeeded():                state = reset_state(system, speciation_ratio_mol_kg)            # If the result failed, we will use spline            else:                log.warning(f"While attempting to find bottom freezing temperature for pressure of {P_MPa} MPa, \n"                            +f"Reaktoro was unable to find a temperature within range of {TMin_K} K and {TMax_K}.\n"                            +f"Instead, we will use a spline of freezing temperatures that we generated for this EOS to find the associated freezing temperature.")                equilibrium_temperature = freezing_temperature_spline(P)                state = reset_state(system, speciation_ratio_mol_kg)        # If Pressure is >= PMax, Reaktoro is at its limits of computation and will likely fail. Thus, we utilize our spline approximation of freezing temperatures        # over a range of pressures that we are confident that Frezchem works at and find the associated freezing temperature at the given pressure.        # If the temperature we are querying over is less than that freezing temperature, then we assume its ice, otherwise we assume its liquid        else:            equilibrium_temperature = freezing_temperature_spline(P)        freezing_temperatures.append(equilibrium_temperature)        calculated_freezing_temperatures[P] = equilibrium_temperature    # Return the equilibrium temperature    return np.array(freezing_temperatures)def Frezchem_Spline_Generator(aqueous_species_list, speciation_ratio_mol_kg, data_points = 15, significant_threshold = 0.1):    P_MPa = np.linspace(0.1, 100, data_points)    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    TMin_K = 240    TMax_K = 300    # Create Reaktoro objects    # db, system, state, conditions, solver, props = PhreeqcGeneratorForChemicalConstraint(aqueous_species_list, speciation_ratio_mol_kg, "frezchem.dat")    db, system, state, conditions, solver, props = PhreeqcGeneratorForChemicalConstraint(aqueous_species_list, speciation_ratio_mol_kg, "frezchem_new2.dat")    # Create freezing temperatures list and indices of pressures to remove, if necessary    freezing_temperatures = []    indices_to_remove = []    for index, P in enumerate(P_MPa):        # Specify equilibrium constraints        conditions.pressure(P, "MPa")        conditions.set("IP", significant_threshold)        conditions.setLowerBoundTemperature(TMin_K, "K")        conditions.setUpperBoundTemperature(TMax_K, "K")        # Solve the equilibrium problem        result = solver.solve(state, conditions)        # Update the properties        props.update(state)        # Obtain the equilibrium temperature        equilibrium_temperature = props.temperature()        # Correct equilibrium temperature with correction spline        corrected_temperature = equilibrium_temperature + temperature_correction_spline(P)        # Check if the result succeeded        if result.succeeded():            freezing_temperatures.append(corrected_temperature)            state = reset_state(system, speciation_ratio_mol_kg)        # If the result failed, then do not include this in list of freezing temperatures and remove from pressure list to avoid its use in creating spline        else:            indices_to_remove.append(index)    # Remove pressures that failed to find equilibrium    P_MPa = np.delete(P_MPa, indices_to_remove)    # Convert freezing_temperatures to array    freezing_temperatures = np.array(freezing_temperatures)    # Create b-spline    t, c, k = splrep(P_MPa, freezing_temperatures)    spline = BSpline(t, c, k, extrapolate=True)    # Find highest pressure at which Frezchem could find freezing temperature for given composition    max_pressure = P_MPa[-1]    # Return spline and max pressure    return spline, max_pressureclass RktSeismic():    def __init__(self, aqueous_species_list, speciation_ratio_mol_kg, TMin_K, TMax_K, PMin_MPa, PMax_MPa):        """        Initialize the RKtSeismic() object with the minimum and maximum T (in K) and P (in MPa) and speciation info.        """        self.aqueous_species_list = aqueous_species_list        self.speciation_ratio_mol_kg = speciation_ratio_mol_kg        self.TMin_K = TMin_K        self.TMax_K = TMax_K        self.PMin_MPa = PMin_MPa        self.PMax_MPa = PMax_MPa    def __call__(self, P_MPa, T_K, grid = False):        """        Finds the sound speed in km/s and bulk modulus in GPa for the input of P_MPa and T_K        Args:            P_MPa (float, Shape N): Array of pressures            T_K (float, Shape N): Array of temperatures            grid: Whether or not they need to be made into a coordinate grid        Returns:            VP_kms (float, Shape N): Corresponding sound speeds in km/s            KS_GPa (float, Shape N): Corresponding bulk modulus in GPa        """        if grid:            P_MPa, T_K = np.meshgrid(P_MPa, T_K, indexing='ij')        else:            P_MPa = np.array(P_MPa)            T_K = np.array(T_K)            if (np.size(P_MPa) == 0 or np.size(T_K) == 0):                # If input is empty, return empty array                return np.array([])            elif ((np.size(P_MPa) != np.size(T_K)) and not (np.size(P_MPa)==1 or np.size(T_K)==1)):                # If arrays are different lengths, they are probably meant to get a 2D output                P_MPa, T_K = np.meshgrid(P_MPa, T_K, indexing='ij')        # Finds the sound speed and associated densities for the given pressure and temperature inputs        VP_kms, rho_kgm3 = seismic_calculations(self.aqueous_species_list, self.speciation_ratio_mol_kg, P_MPa, T_K)        # Calculates the bulk modulus from its relaiontship with sound speed and density        KS_GPa = rho_kgm3 * VP_kms**2*1e-3 # 1e-3 because (km/s)^2 * (kg/m^3) gives units of MPa, so 1e-3 to convert to GPa        # Return sound speed and bulk modulus        return VP_kms, KS_GPadef seismic_calculations(aqueous_species_list, speciation_ratio_mol_kg, P_MPa, T_K, database = "supcrt16"):    """    Calculates the sound speed and densities of the aqueous phase of the solution for the input pressure and temperatures,    utilizing the thermodynamic properties provided by the supcrt database at equilibrium.    Args:        aqueous_species_list: aqueous species in reaction. Should be formatted in one long string with a space in between each species        speciation_ratio_mol_kg: the ratio of species in the aqueous solution in mol/kg of water. Should be a dictionary with the species as the key and its ratio as its value.        P_MPa (float, shape N): the desired equilibrium freezing pressure(s) in an array of size N.        T_K (float, shape N): the desired equilibrium freezing temperature(s) in an array of size N.    Returns:        sound_speeds (float, shape N): Associated aqueous sound speeds in km/s        densities (float, shape N): Associated aqueous densities in km/s    """    # Convert H2O label to H2O(aq) label for compatability with Supcrt database    aqueous_species_list, speciation_ratio_mol_kg = species_convertor_compatible_with_supcrt(        aqueous_species_list, speciation_ratio_mol_kg)    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    # Create list that will become array that will hold sound speeds    sound_speeds = []    # Create list that will become array taht holds corresponding aqueous densities    densities = []    # Create Reaktoro objects    db, system, state, conditions, solver, props = SupcrtGenerator(aqueous_species_list,                                                                                  speciation_ratio_mol_kg, database)    # Create an iterator to go through P_MPa and T_K    it = np.nditer([P_MPa, T_K], flags =['multi_index'])    # Go through each (P,T) combination, where we assume that P_MPa and T_K are same size and correspond to one another    for P, T in it:        P = float(P)        T = float(T)        conditions.temperature(T, "K")        conditions.pressure(P, "MPa")        # Solve the equilibrium problem        result = solver.solve(state, conditions)        # Update the properties        props.update(state)        # Check if the equilibrium problem succeeded        if result.succeeded():            # If it did succeed, obtain the relevant aqueous only phase props            aqueous_props = props.phaseProps("AqueousPhase")            # Obtain density, specific volume, and pressure derivative of specific volume            density_kg_m3 = float(aqueous_props.density())            specific_volume_m3_kg = float(aqueous_props.specificVolume())            pressure_derivative_specific_volume = float(aqueous_props.specificVolumeP())            # Calculate commpressibility factor, multiplying negative inverse of specific volume by pressure derivative of specific volume            k_compressibility = -(1/specific_volume_m3_kg)*pressure_derivative_specific_volume            # Calculate sound speed, multiplying k by density and taking the product to the -0.5            c_m_s = (density_kg_m3*k_compressibility)**(-0.5)            # Convert to km/s            c_km_s = c_m_s / 1000            # Append to lists            sound_speeds.append(c_km_s)            densities.append(density_kg_m3)            # Reset the state            state = reset_state(system, speciation_ratio_mol_kg)        # If equilibrium did not succeed, then we will linearly interpolate these values        # THIS IS VERY UNLIKELY SINCE WE ARE CALCULATING SEISMIC VALUES FOR OCEAN LAYER WHICH HAS ALREADY BEEN CALCULATED BY RKT, SO VALUES SHOULD BE WITHIN RANGE OF RKT        else:            # For now, just append zero and we will handle later            sound_speeds.append(0.0)            densities.append(0.0)            # Reset the state            state = reset_state(system, speciation_ratio_mol_kg)    # Convert lists to arrays    sound_speeds = np.array(sound_speeds).reshape(P_MPa.shape)    densities = np.array(densities).reshape(P_MPa.shape)    # Check if any values are zero, which indicates they were not found in chemical equilibrium    # THIS IS VERY UNLIKELY SINCE RKT SHOULD BE ABLE TO HANDLE INPUT P AND T RANGE, HOWEVER FOR SELF-CONSISTENCY WE ADD THIS IN CASE    zero_indices = np.argwhere(densities == 0)    if np.size(zero_indices) != 0:        sound_speeds, densities = interpolation_2d_seismic(zero_indices, sound_speeds, densities)    return sound_speeds, densitiesclass RktConduct():    def __init__(self, aqueous_species_list, speciation_ratio_mol_kg):        """        Initialize the RKtConduct() object and parse the aqueous species list into a format compatible with elecCondMcClevskey2012()        """        self.ions = McClevskyIonParser(aqueous_species_list, speciation_ratio_mol_kg)    def __call__(self, P_MPa, T_K, grid = False):        """        Finds electrical conductivity for given ions. Currently does not adjust for pressure.        Args:            Array of pressures            T_K (float, Shape N): Array of temperatures            grid: Whether or not they need to be made into a coordinate grid        Returns:            VP_kms (float, Shape N): Corresponding sound speeds in km/s            KS_GPa (float, Shape N): Corresponding bulk modulus in GPa        """        if grid:            P_MPa, T_K = np.meshgrid(P_MPa, T_K, indexing='ij')        else:            P_MPa = np.array(P_MPa)            T_K = np.array(T_K)            if (np.size(P_MPa) == 0 or np.size(T_K) == 0):                # If input is empty, return empty array                return np.array([])            elif ((np.size(P_MPa) != np.size(T_K)) and not (np.size(P_MPa)==1 or np.size(T_K)==1)):                # If arrays are different lengths, they are probably meant to get a 2D output                P_MPa, T_K = np.meshgrid(P_MPa, T_K, indexing='ij')        T_C = T_K - Constants.T0        ions = elecCondMcCleskey2012(P_MPa, T_C, self.ions)        sigma_data = ions['sigma_Sm']        return sigma_dataclass Reaktoro_Hydro_Species_Generator():    def __init__(self, aqueous_species_list, speciation_ratio_mol_kg):        # Convert H2O label to H2O(aq) label for compatability with Supcrt database        self.aqueous_species_list, self.speciation_ratio_mol_kg = species_convertor_compatible_with_supcrt(aqueous_species_list, speciation_ratio_mol_kg)        self.supcrt = SupcrtGenerator(self.aqueous_species_list, self.speciation_ratio_mol_kg,"supcrt16")    def __call__(self, P_MPa, T_K, grid = False):        if grid:            P_MPa, T_K = np.meshgrid(P_MPa, T_K, indexing='ij')        else:            P_MPa = np.array(P_MPa)            T_K = np.array(T_K)            if (np.size(P_MPa) == 0 or np.size(T_K) == 0):                # If input is empty, return empty array                return np.array([])            elif ((np.size(P_MPa) != np.size(T_K)) and not (np.size(P_MPa) == 1 or np.size(T_K) == 1)):                # If arrays are different lengths, they are probably meant to get a 2D output                P_MPa, T_K = np.meshgrid(P_MPa, T_K, indexing='ij')        return species_at_equilibrium(P_MPa, T_K, self.supcrt, self.speciation_ratio_mol_kg)def species_at_equilibrium(P_MPa, T_K, supcrt, speciation_ratio_mol_kg):    db, system, state, conditions, solver, props = supcrt    df = panda_df_generator(system)    try:        aprops = rkt.AqueousProps(state)    except:        aprops = None    state = rkt.ChemicalState(state)    # Create an iterator to go through P_MPa and T_K    it = np.nditer([P_MPa, T_K], flags =['multi_index'])    # Go through each (P,T) combination, where we assume that P_MPa and T_K are same size and correspond to one another    for P, T in it:        P = float(P)        T = float(T)        conditions.temperature(T, "K")        conditions.pressure(P, "MPa")        # Solve the equilibrium problem        result = solver.solve(state, conditions)        # Update the properties        props.update(state)        # Check if the equilibrium problem succeeded        if result.succeeded():            # Obtain species amount            props.update(state)            if aprops is not None:                aprops.update(state)                pH = aprops.pH()            else:                pH = np.nan            amounts = []            for speciesItem in system.species():                amounts.append(float(state.speciesAmount(speciesItem.name())))            # Obtain phase amounts            liquidAmount = [float(sum(state.speciesAmountsInPhase("AqueousPhase")))]            solidAmount = [float(sum([state.speciesAmount(solid) for solid in                                      props.indicesSpeciesInPhasesWithSolidState()]))]            # Obtain charge            charge = [np.array(float(state.charge()))]            # Create data row            data = [P] + [T] + [pH] + amounts + charge + solidAmount + liquidAmount            df.loc[len(df)] = data            state = reset_state(system, speciation_ratio_mol_kg)        else:            log.warning(f"Inability to find hydrosphere equilibrium at {P} MPa and {T} K. Will skip and go to next hydrosphere step")    return df"""def ice_freezing(aqueous_species_list, speciation_ratio_mol_kg, P_MPa, T_K, PMax_MPa, TMin_K, TMax_K, freezing_temperatures_spline, frezchem_database, core_database, significant_threshold = 0.1):     Calculates whether ice is freezing at the given temperature and pressure. Utilizes the reaktoro framework to     constrain the equilibrium position at the prescribed pressure and temperature with the given composition,     and determines if ice has formed at a significant threshold of 1e-14, therefore calculating the phase of the solution     and returning true if the phase is ice and false if the phase is liquid.     Parameters     ----------     aqueous_species_list: aqueous species in reaction. Should be formatted in one long string with a space in between each species     speciation_ratio_mol_kg: the ratio of species in the aqueous solution in mol/kg of water. Should be a dictionary     with the species as the key and its ratio as its value.     P_MPa (float, shape N): the desired equilibrium freezing pressure(s) in an array of size N.     T_K (float, shape N): the desired equilibrium freezing temperature(s) in an array of size N.     significant_threshold: the amount of moles of ice present for H2O to be considered in solid phase. Default is 1e-14 moles.     Returns     -------     ice_present (boolean, shape N): an array of true and falses that indicate whether for prescribed P_MPa and T_K coordinates        if there is ice present at significant threshold (default of 1e-14)    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    # Create list that holds boolean values of whether ice is present    ice_present = []    # Create an iterator to go through P_MPa and T_K    it = np.nditer([P_MPa, T_K], flags =['multi_index'])    for P, T in it:        P = float(P)        T = float(T)        # Check that pressure is below PMax_MPa, the maximum pressure constraint calculated previously        if P <= PMax_MPa:            # Determine whether to use frezchem or core database based on temperature            if T < 298.15:                db, system, state, conditions, solver, props, ice_name, database_name = frezchem_database            else:                db, system, state, conditions, solver, props, ice_name, database_name = core_database            # Specify equilibrium conditions            conditions.pressure(P, "MPa")            conditions.temperature(T, "K")            # Solve the equilibrium problem            result = solver.solve(state, conditions)            # Update the properties            props.update(state)            # Check if the equilibrium problem succeeded            if result.succeeded():                # If so, obtain the total amount of solid H2O at equilibrium in moles                ice_amount = props.speciesAmount(ice_name)                # If the amount of solid H2O at equilibrium is > the significant threshold, then append true to the list, otherwise append false                ice_present.append(ice_amount > significant_threshold)                # Reset the state                state = reset_state(system, speciation_ratio_mol_kg)            # Otherwise, the equilibrium problem failed so we need to handle it accordingly            else:                # Warn the user about the failed equilibrium (good for debugging)                log.debug(                    f"Unsuccessful computation at: {props.pressure() / 1e+6} MPa and {props.temperature()} K.\n"                    f"The temperature and pressure may be out of bounds, but sometimes Reaktoro fails to converge on specific values even within bounds.\n"                    f"Will take an alternative approach of rerunning the equilibrium calculation by determining the temperature at which ice begins to forms at the given pressure and composition,\n"                    f"and if this temperature is below the freezing temperature then we will assume the state is solid, and if the temperature is above the freezing temperature then we will assume the state is liquid.")                # Instead, we will find the associated freezing temperature with the prescribed pressure and compare that freezing temperature to T                freezing_temperature = rkt_t_freeze(aqueous_species_list, speciation_ratio_mol_kg, P, TMin_K,                                                    TMax_K, database_name, significant_threshold)                # If T is <= the freezing temperature for the given pressure, then we will assume ice is also present at this temperature and append True to list                # Otherwise, if T > the freezing temperature, we will assume ice is not present and append False to list                ice_present.append(T <= freezing_temperature)  # If T <= freezing_temperature, then we assume ice is present                # Reset the state                state = reset_state(system, speciation_ratio_mol_kg)        # If Pressure is >= PMax, Reaktoro is at its limits of computation and will likely fail. Thus, we utilize our spline approximation of freezing temperatures        # over a range of pressures that we are confident that Frezchem works at and find the associated freezing temperature at the given pressure.        # If the temperature we are querying over is less than that freezing temperature, then we assume its ice, otherwise we assume its liquid        else:            TFreezing_At_P = freezing_temperatures_spline(P)            ice_present.append(T < TFreezing_At_P)    # Convert the ice_present list into an array (of shape N) and return    ice_present = np.reshape(ice_present, P_MPa.shape)    return ice_present """