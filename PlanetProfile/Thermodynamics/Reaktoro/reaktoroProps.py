import copyimport reaktoro as rktimport numpy as npimport loggingfrom PlanetProfile.Utilities.defineStructs import Constantsfrom scipy.optimize import root_scalar as GetZero# Assign loggerlog = logging.getLogger('PlanetProfile')def RktProps(aqueous_species_list, speciation_ratio_mol_kg, P_MPa, T_K):    """ Determine density rho, heat capacity Cp, thermal expansivity alpha,        and thermal conductivity kTherm as functions of pressure P and        temperature T for the provided solution species list and corresponding molarity ratios.        Implements Reaktoro Supcrt database to find these thermal properties at equilibrium for the prescribed pressure and temperature.    Args:        aqueous_species_string: String that has all species names that should be considered in aqueous phase        speciation_ratio_mol_kg: Dictionary of active species and the values of their molar ratio (mol/kg of water)        P_MPa (float, shape N): Pressures in MPa        T_K (float, shape M): Temperature in K        Returns:            rho_kgm3 (float, shape NxM): Mass density of liquid in kg/m^3            Cp_JkgK (float, shape NxM): Isobaric heat capacity of liquid in J/(kg K)            alpha_pK (float, shape NxM): Thermal expansivity of liquid in 1/K            kTherm_WmK (float, shape NxM): Thermal conductivity of liquid in W/(m K)    """    # Convert H2O label to H2O(aq) label for compatability with Supcrt database    aqueous_species_list, supcrt_speciation_ratio_mol_kg = species_convertor_compatible_with_supcrt(aqueous_species_list, speciation_ratio_mol_kg)    # Create lists of thermodynamic properties that will be of length NxM    rho_kgm3 = []    Cp_JKgK = []    alpha_pK = []    kTherm_WmK = []    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    # Go through each (P,T) combination, iterating through each P in P_MPa for a T in T_K    # To increase efficiency, set up the chemical problem before iterating through each P    for T in T_K:        # Initilialize the database        db = rkt.SupcrtDatabase("supcrt16")        # Prescribe the solution and solids        solution = rkt.AqueousPhase(aqueous_species_list)        solids = rkt.MineralPhases()        # Initialize the system        system = rkt.ChemicalSystem(db, solution, solids)        # Create constraints on equilibrium - pressure and temperature        specs = rkt.EquilibriumSpecs(system)        specs.pressure()        specs.temperature()        # Create a solver object        solver = rkt.EquilibriumSolver(specs)        # Create a chemical state and its associated properties        state = rkt.ChemicalState(system)        props = rkt.ChemicalProps(state)        # Establish equilibrium constraint values        conditions = rkt.EquilibriumConditions(specs)        conditions.temperature(T, "K")        # Now that we have created a Reaktoro instance for a given temperature, go through each pressure        for P in P_MPa:            #Establish equilibrium pressure constraint value            conditions.pressure(P, "MPa")            # Populate the state with the prescribed species at the given ratios            for ion, ratio in supcrt_speciation_ratio_mol_kg.items():                state.add(ion, ratio, "mol")            # Solve the equilibrium problem            result = solver.solve(state, conditions)            # Update the properties            props.update(state)            # Check if the equilibrium problem succeeded            if result.succeeded():                # Obtain the relevant aqueous only phase props                aqueous_props = props.phaseProps("AqueousPhase")                # Obtain the thermodynamic properties of the aqueous phase                rho_kg_m3 = aqueous_props.density()                Cp_J_kg_K = aqueous_props.specificHeatCapacityConstP()                # To calculate thermal coefficient, we will multiply inverse of specific volume by its                # partial derivative with respect to temperature                specific_volume_m3_kg = aqueous_props.specificVolume()                dSpecificVolumedT = aqueous_props.specificVolumeT()                thermalExpansivity_1_K = 1 / float(specific_volume_m3_kg) * float(dSpecificVolumedT)                # Append the values to the associated array                rho_kgm3.append(float(rho_kg_m3))                Cp_JKgK.append(float(Cp_J_kg_K))                alpha_pK.append(thermalExpansivity_1_K)                # Reset the state                state = rkt.ChemicalState(system)            # Otherwise, the equilibrium problem failed so we need to handle it accordingly            # NEED TO COME UP WITH SELF CONSISTENT WAY TO HANDLE REAKTORO DIVERGENCE ERRORS            else:                log.warning(                    f"Unsuccessful computation at: {props.pressure() / 1e+6} MPa and {props.temperature()} K.\n"                    f"The temperature and pressure may be out of bounds, thus we will extrapolate this value from the previous ones. STILL NEEDS TO BE IMPLEMENTED")                # Reset the state                state = rkt.ChemicalState(system)                # NEED TO COME UP WTIH SELF CONSISTENT WAY TO EXTRAPOLATE TEHESE VALUES                rho_kgm3.append(1000)                Cp_JKgK.append(0.0)                alpha_pK.append(0.0)    # Turn the list into an array and transpose it into a format identical to what PP does, where pressure is in row and temperature is in columns    rho_kgm3 = np.array(rho_kgm3).reshape(len(T_K), len(P_MPa)).T    Cp_JKgK = np.array(Cp_JKgK).reshape(len(T_K), len(P_MPa)).T    alpha_pK = np.array(alpha_pK).reshape(len(T_K), len(P_MPa)).T    # Thermal conductivity not provided by RKT, for now return constant thermal conductivity of water    kTherm_WmK = np.zeros_like(alpha_pK) + Constants.kThermWater_WmK    # NEED TO ADD AN EXTRAPOLATION FUNCTIONALITY FOR ALL ZEROS IN THE ARRAYS    return rho_kgm3, Cp_JKgK, alpha_pK, kTherm_WmKdef lowest_temperature_allowed(aqueous_species_list, speciation_ratio_mol_kg, P_MPa, T_K):    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    # Go through each (P,T) combination, iterating through each P in P_MPa for a T in T_K    # To increase efficiency, set up the chemical problem before iterating through each P    # Initilialize the database    db = rkt.SupcrtDatabase("supcrt16")    # Prescribe the solution and solids    solution = rkt.AqueousPhase(aqueous_species_list)    solids = rkt.MineralPhases()    # Initialize the system    system = rkt.ChemicalSystem(db, solution, solids)    # Create constraints on equilibrium - pressure and temperature    specs = rkt.EquilibriumSpecs(system)    specs.pressure()    specs.temperature()    # Create a solver object    solver = rkt.EquilibriumSolver(specs)    # Create a chemical state    state = rkt.ChemicalState(system)    for ion, ratio in speciation_ratio_mol_kg.items():        state.add(ion, ratio, "mol")    # Establish equilibrium constraint values    conditions = rkt.EquilibriumConditions(specs)    conditions.temperature(T_K, "K")    conditions.pressure(P_MPa, "MPa")    # Solve the equilibrium problem    result = solver.solve(state, conditions)    # If result succeeded, return true, otherwise returnt false    if result.succeeded():        return 0.5    else:        return -0.5def species_convertor_compatible_with_supcrt(aqueous_species_list, speciation_ratio_mol_kg):    if "H2O" in aqueous_species_list:        aqueous_species_list = aqueous_species_list.replace("H2O", "H2O(aq)")        # Since python passes dictionary by reference, need to make deep copy to preserve original dictionary        supcrt_speciation_ratio_mol_kg = copy.deepcopy(speciation_ratio_mol_kg)        supcrt_speciation_ratio_mol_kg["H2O(aq)"] = supcrt_speciation_ratio_mol_kg.pop("H2O")        return aqueous_species_list, supcrt_speciation_ratio_mol_kg    else:        return aqueous_species_list, speciation_ratio_mol_kgclass RktPhase():    def __init__(self, aqueous_species_list, speciation_ratio_mol_kg, TMin_K, TMax_K, PMin_MPa, PMax_MPa):        self.aqueous_species_list = aqueous_species_list        self.speciation_ratio_mol_kg = speciation_ratio_mol_kg        self.TMin_K = TMin_K        self.TMax_K = TMax_K        self.PMin_MPa = PMin_MPa        self.PMax_MPa = PMax_MPa        # Obtain the freezing temperature at PMax - this will drasticaslly decrease runtime when this object is called since        # rkt_t_freeze won't have to be called each time        self.TFreezing_At_PMax = rkt_t_freeze(aqueous_species_list, speciation_ratio_mol_kg, self.PMax_MPa, TMin_K, TMax_K, "frezchem.dat")    def __call__(self, P_MPa, T_K, grid = False):        # Convert a 0-d numpy array into a float        if np.size(P_MPa) == 1:            P_MPa = np.atleast_1d(P_MPa)        if np.size(T_K) == 1:            T_K = np.atleast_1d(T_K)        # Similar approach to SF, where we specify the P_MPa and T_K at equilibrium, and ice_freezing function returns        # if ice has formed or not at given temperature and pressure. Then, GetZero function will query over pressures to find        # bottom pressure at which ice begins to form for bottom pressure.        return ice_freezing(self.aqueous_species_list, self.speciation_ratio_mol_kg, P_MPa, T_K, self.TMin_K, self.TMax_K, self.TFreezing_At_PMax).astype(np.int_)        '''        # IDENTICAL APPROACH TO GSW        # 1. Subtract the freezing temperature from the input temperature        # 2. Compare to zero -- if we are below the freezing temp, it's ice I, above, liquid        # 3. Cast the above comparison (True if less than Tfreeze, False if greater) to int,        #       so that we get 1 if we are below the freezing temp and 0 if above.        return (T_K - rkt_t_freeze(self.aqueous_species_list, self.speciation_ratio_mol_kg, P_MPa, self.TMin_K,                            self.TMax_K) < 0).astype(np.int_)        Alternative approach is to obtain Pfreezing from the prescribed T_K, since the way PlanetProfile obtains the Melting EOS,        this class will not have access to the hydrosphere TMin and TMax which I am using to constrain Reaktoro's search.        Instead, can use the constraints of         PMin to PMax to find the freezing pressure for a prescribed temperature via Reaktoro.        return (P_MPa - rkt_p_freeze(self.aqueous_species_list, self.speciation_ratio_mol_kg, T_K, self.PMin_MPa,                            self.PMax_MPa) < 0).astype(np.int_)        '''def SpeciesParser(species_string_with_ratios):    '''    Converts the provided String of species and their molar ratios into formats necessary for Reaktoro. Namely, creates    a String of all the species in the list and a dictionary with 'active' species that are added to solution (the observer species are    automatically generated to be 1e-16 moles in the solution by Reaktoro). It also returns the w_ppt of the solution. If any of the species do not exist in the database Reaktoro is implementing    (namely frezchem), this method raises an error that the species does not exist.     Parameters     ----------     species_string_with_ratios: String of all the species that should be considered in aqueous phase and their corresponding molar ratios.        For example, "Cl-: 19.076, Na+: 5.002, Ca2+: 0.0"     Returns     -------     aqueous_species_string: String that has all species names that should be considered in aqueous phase     speciation_ratio_mol_kg: Dictionary of active species and the values of their molar ratio (mol/kg of water)    '''    db = rkt.PhreeqcDatabase("frezchem.dat")    aqueous_species_string = ""    speciation_ratio_mol_kg = {}    # Go through each species and corresponding ratio_mol_kg and add to corresponding lists    for species_with_ratio in species_string_with_ratios.split(", "):        species, ratio_mol_kg = species_with_ratio.split(": ")        # Ensure that species is in frezchem database and if not then raise error        try:            db.species(species)        except:            raise ValueError(f'{species} does not exist in the frezchem database. Check that it is spelled correctly')        aqueous_species_string = aqueous_species_string + species + " "        # Check if the species is active (amount > 0 mol) and if so, add it to the dictionary        if (float(ratio_mol_kg) > 0):            speciation_ratio_mol_kg[species] = float(ratio_mol_kg)    # Check if water is in the aqueous species string and dictionary and if not, add it, ensuring to update the weight to be 1kg    if not "H2O" in aqueous_species_string:        aqueous_species_string = aqueous_species_string + "H2O "    speciation_ratio_mol_kg.update({"H2O": float(1/rkt.waterMolarMass)}) #Adds mols of H2O for 1kg of total solution    # Return the species string and dictionary (remove the trailing white space from the String as well with rstrip())    return aqueous_species_string.rstrip(" "), speciation_ratio_mol_kgdef database_to_use(T_K):    """ Decides between frezchem.dat and core10.dat database to use according to the temperature.        As per Comparison of thermodynamic data files for PHREEQC (Lu et. al 2022):            frezchem.dat: −73–25°C at 1 bar            core10.dat: 0.01–100°C at 1bar, 100–300°C along P_Sat (water vapor saturation pressure)        Currently, frezchem will be utilized for 200K<T<298.15T, and dat10 for T>=298.15.    Args:        T_K: The temperature to determine between frezchem.dat and core10.dat    Returns:        database: the database to use according to the temperature criteria above        ice_name: the name of H2O solid state for the database, which has different labels for the databases.    """    if 200 < T_K and T_K < 298.15:        database = "frezchem.dat"  # Frezchem is compatible from 200 to 298.15K        ice_name = "Ice(s)"    else:        database = "core10.dat"        ice_name = "Ice"    return database, ice_namedef ices_phases_amount_mol(props: rkt.ChemicalProps):    '''    Calculate the total amount of moles of all ices in the current state using its associated properties. Function is used in    the ice constraint for rkt_p_freeze().    '''    # Get name of H2O ice (either Ice(s) for frezchem or Ice for core10.dat)    ice_name = ""    try:        props.system().database().species("Ice(s)")        ice_name = "Ice(s)"    except Exception as e:        ice_name = "Ice"    return props.speciesAmount(ice_name)def ice_freezing(aqueous_species_list, speciation_ratio_mol_kg, P_MPa, T_K, TMin_K, TMax_K, TFreezing_At_PMax):    """     Calculates whether ice is freezing at the given temperature and pressure. Utilizes the reaktoro framework to     constrain the equilibrium position at the prescribed pressure and temperature with the given composition,     and determines if ice has formed at a significant threshold of 1e-14, therefore calculating the phase of the composition     and returning true if the phase is ice and false if the phase is liquid.     Parameters     ----------     aqueous_species_list: aqueous species in reaction. Should be formatted in one long string with a space in between each species     speciation_ratio_mol_kg: the ratio of species in the aqueous solution in mol/kg of water. Should be a dictionary     with the species as the key and its ratio as its value.     P_MPa: the desired equilibrium freezing pressure(s).     T_K: the desired equilibrium freezing temperature(s).     Returns     -------     ice_present_array: an array of true and falses that indicate whether for prescribed P_MPa and T_K, if there is ice present at significant threshold of 1e-14.     """    ice_present_array = []    # Go through each (P,T) combination, where we assume that P_MPa and T_K are same size and correspond to one another    for i in range(np.size(P_MPa)):        P = P_MPa[i]           # Ensure that the pressure is below 100MPa, the maximum pressure that Phreeqc can handle        if P < 100:            T = T_K[i]            ice_name = ""            # Check the temperature to determine which database (core10 or frezchem) to use            database = ""            if 200 < T and T < 298.15:                database = "frezchem.dat"  # Frezchem is compatible from 200 to 298.15K                ice_name = "Ice(s)"            else:                database = "core10.dat"                ice_name = "Ice"            # Initilialize the database            db = rkt.PhreeqcDatabase(database)            # Prescribe the solution            solution = rkt.AqueousPhase(aqueous_species_list)            # Obtain all related solid phases            solids = rkt.MineralPhases()            # Initialize the system            system = rkt.ChemicalSystem(db, solution, solids)            # Create constraints on equilibrium - pressure and significant threshold for ice            specs = rkt.EquilibriumSpecs(system)            specs.pressure()            specs.temperature()            # Create a solver object            solver = rkt.EquilibriumSolver(specs)            # Create a chemical state and its associated properties            state = rkt.ChemicalState(system)            props = rkt.ChemicalProps(state)            # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.            rkt.Warnings.disable(906)            conditions = rkt.EquilibriumConditions(specs)            conditions.pressure(P, "MPa")            conditions.temperature(T, "K")            # Populate the state with the prescribed species at the given ratios            for ion, ratio in speciation_ratio_mol_kg.items():                state.add(ion, ratio, "mol")            # Solve the equilibrium problem            result = solver.solve(state, conditions)            # Update the properties            props.update(state)            # Check if the equilibrium problem succeeded            if result.succeeded():                ice_amount = props.speciesAmount(ice_name)                ice_present_array.append(ice_amount > 1e-14)                # Reset the state                state = rkt.ChemicalState(system)            # Otherwise, the equilibrium problem failed so we need to handle it accordingly            else:                log.warning(                    f"Unsuccessful computation at: {props.pressure() / 1e+6} MPa and {props.temperature()} K.\n"                    f"The temperature and pressure may be out of bounds, but sometimes Reaktoro fails to converge on specific values even within bounds.\n"                    f"Will take an alternative approach of rerunning the equilibrium calculation by determining the temperature at which ice begins to forms at the given pressure and composition,\n"                    f"and if this temperature is below the freezing temperature then we will assume the state is solid, and if the temperature is above the freezing temperature then we will assume the state is liquid.")                freezing_temperature = rkt_t_freeze(aqueous_species_list, speciation_ratio_mol_kg, P, TMin_K, TMax_K, database)                ice_present_array.append(T <= freezing_temperature) # If T <= freezing_temperature, then we assume ice is present                # Reset the state                state = rkt.ChemicalState(system)        # If Pressure is >= PMax, Reaktoro is at its limits of computation and will likely fail. Thus, we can compare T_K[i] to        # the freezing temperature at P_Max, which we have already saved. This alternative approach will yield good results in addition to        # drastically improving runtime by not needing to create a Reaktoro object each instance that PMax is reached.        else:            ice_present_array.append(T_K[i] < TFreezing_At_PMax)    # Convert the p_temperature_K list into an array and return    ice_present_array = np.array(ice_present_array)    return ice_present_arraydef rkt_t_freeze(aqueous_species_list, speciation_ratio_mol_kg, P_MPa, TMin_K, TMax_K, database):    """     Calculates the temperature at which the prescribed aqueous solution freezes. Utilizes the reaktoro framework to     constrain the equilibrium position at the prescribed pressure, the lower and upper limits of temperature (in MPa),     and the total amount of ice at a significant threshold of 1e-14, therefore calculating and returning the     temperature (within the range) at which ice begins to form.     Parameters     ----------     aqueous_species_list: aqueous species in reaction. Should be formatted in one long string with a space in between each species     speciation_ratio_mol_kg: the ratio of species in the aqueous solution in mol/kg of water. Should be a dictionary     with the species as the key and its ratio as its value.     P_MPa: the desired equilibrium freezing pressure(s). If P_MPa is a list, then we must return the associated freezing temperature for each pressure.     TMin_K: the lower limit of temperature that Reaktoro should query over     TMax_K: the upper limit of temperature that Reaktoro should query over     Returns     -------     t_freezing_K: the temperature at which the solution begins to freeze. If P_MPa is a list, then returns an equal size list with associated bottom temperatures.     """    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    # Initialize the database with the corersponding database    db = rkt.PhreeqcDatabase(database)    # Prescribe the solution    solution = rkt.AqueousPhase(aqueous_species_list)    # Obtain all related solid phases    solids = rkt.MineralPhases()    # Initialize the system    system = rkt.ChemicalSystem(db, solution, solids)    # Create constraints on equilibrium - pressure and significant threshold for ice    specs = rkt.EquilibriumSpecs(system)    specs.pressure()    specs.unknownTemperature()    # Create equilibrium constraint on the phase amount of ices to 1e-14    # This constraint will allow Reaktoro to query for the pressure at which ice begins to form at the prescribed pressure    ice_phase_final = 1e-14  # Establish the desired equilibrium amount of total ices (1e-14 moles)    idx_ice_phase = specs.addInput("IP")    ices_phase_constraint = rkt.EquationConstraint()    ices_phase_constraint.id = "icePhaseAmountConstraint"    ices_phase_constraint.fn = lambda props, w: ices_phases_amount_mol(props) - w[idx_ice_phase]    specs.addConstraint(ices_phase_constraint)    # Create a solver object    solver = rkt.EquilibriumSolver(specs)    # Create a chemical state and its associated properties    state = rkt.ChemicalState(system)    props = rkt.ChemicalProps(state)    # Prescribe the equilibrium constraints on pressure at P_MPa, ice phase amount at the significant threshold,    # and the temperatures to query over    conditions = rkt.EquilibriumConditions(specs)    conditions.pressure(P_MPa, "MPa")    conditions.set("IP", ice_phase_final)    conditions.setLowerBoundTemperature(TMin_K, "K")    conditions.setUpperBoundTemperature(TMax_K, "K")    # Populate the state with the prescribed species at the given ratios    for ion, ratio in speciation_ratio_mol_kg.items():        state.add(ion, ratio, "mol")    # Solve the equilibrium problem    result = solver.solve(state, conditions)    # Update the properties    props.update(state)    equilibrium_temperature = props.temperature()    # Reset the state    state = rkt.ChemicalState(system)    # return the equilibrium temperature    return equilibrium_temperature# Pressure freezing calculation; not utilized currentlydef rkt_p_freeze(aqueous_species_list, speciation_ratio_mol_kg, T_K, PLower_MPa, PUpper_MPa):    """    Calculates the pressure at which the prescribed aqueous solution freezes. Utilizes the reaktoro framework to    constrain the equilibrium position at the prescribed T_K, the lower and upper limits of pressure (in MPa),    and the total amount of ice at a significant threshold of 1e-14, therefore calculating and returning the    pressure (within the range) at which ice begins to form.    Parameters    ----------    aqueous_species_list: aqueous species in reaction. Should be formatted in one long string with a space in between each species    speciation_ratio_mol_kg: the ratio of species in the aqueous solution in mol/kg of water. Should be a dictionary    with the species as the key and its ratio as its value.    T_freezing_K: the desired equilibrium freezing temperature    PLower_MPa: the lower limit of pressure that Reaktoro should query over    PUpper_MPa: the upper limit of pressure that Reaktoro should query over    Returns    -------    p_freezing_MPa: the pressure at which the solution begins to freeze    """    # Initilialize the database with frezchem    db = rkt.PhreeqcDatabase("frezchem.dat")    # Prescribe the solution    solution = rkt.AqueousPhase(aqueous_species_list)    # Obtain all related solid phases    solids = rkt.MineralPhases("Ice(s)")    # Initialize the system    system = rkt.ChemicalSystem(db, solution, solids)    # Create constraints on equilibrium - temperature and significant threshold for ice    specs = rkt.EquilibriumSpecs(system)    specs.temperature()    # Create equilibrium constraint on the phase amount of ices to 1e-14    # This constraint will allow Reaktoro to query for the pressure at which ice begins to form at the prescribed temperature    ice_phase_final = 1e-14 # Establish the desired equilibrium amount of total ices (1e-14 moles)    idx_ice_phase = specs.addInput("IP")    ices_phase_constraint = rkt.EquationConstraint()    ices_phase_constraint.id = "icePhaseAmountConstraint"    ices_phase_constraint.fn = lambda props, w: ices_phases_amount_mol(props) - w[idx_ice_phase]    specs.addConstraint(ices_phase_constraint)    # Create a solver object    solver = rkt.EquilibriumSolver(specs)    # Create a chemical state and its associated properties    state = rkt.ChemicalState(system)    props = rkt.ChemicalProps(state)    # Check if pressure is a list and if so, then query over each pressure and obtain the associated bottom temperature    p_freezing_MPa = []    # Use a for loop to go through each temperature    for temperature in T_K:        # Prescribe the equilibrium constraints on temperature at T_K, ice phase amount at the significant threshold,        # and the pressures to query over        conditions = rkt.EquilibriumConditions(specs)        conditions.temperature(temperature, "K")        conditions.set("IP", ice_phase_final)        conditions.setLowerBoundPressure(PLower_MPa, "MPa")        conditions.setUpperBoundPressure(PUpper_MPa, "MPa")        # Populate the state with the prescribed species at the given ratios        for ion, ratio in speciation_ratio_mol_kg.items():            state.add(ion, ratio, "mol")        # Add a kg of water to the state        # Solve the equilibrium problem        result = solver.solve(state, conditions)        # Update the properties        props.update(state)        # Check if the result failed, and if it did, then it is likely because the freezing pressure could not be found given the pressure constraints.        # Thus, check if the state has reached the pressure limits so append the constraint and add this        if result.failed():            # Check if we have reached the upper pressure constraint            if props.pressure() == PUpper_MPa:                print("Have reached the upper pressure constraint of ", props.pressure, "MPa. Consider raising PMax_MPa")            print("Returning zero as the bottom pressure. Should be handled accordingly.")            p_freezing_MPa.append(np.float_(0))            # Reset the state            state = rkt.ChemicalState(system)        else:            # Otherwise, return the equilibrium state's pressure, which is the bottom pressure (converted to MPa from Pa)            equilibrium_pressure = props.pressure() / 1e+6            print(f"{equilibrium_pressure}MPa at {temperature} K")            p_freezing_MPa.append(equilibrium_pressure)            # Reset the state            state = rkt.ChemicalState(system)    # Convert the p_temperature_K list into an array and return    p_freezing_MPa = np.array(p_freezing_MPa)    return p_freezing_MPa