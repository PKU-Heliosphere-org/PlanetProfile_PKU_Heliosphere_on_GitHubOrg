import copyimport reaktoro as rktimport numpy as npimport loggingfrom PlanetProfile.Utilities.defineStructs import Constants# Assign loggerlog = logging.getLogger('PlanetProfile')def RktProps(aqueous_species_list, speciation_ratio_mol_kg, P_MPa, T_K):    """ Determine density rho, heat capacity Cp, thermal expansivity alpha,        and thermal conductivity kTherm as functions of pressure P and        temperature T for the provided solution species list and corresponding molarity ratios.        Implements Reaktoro Supcrt database to find these thermal properties at equilibrium for the prescribed pressure and temperature.    Args:        aqueous_species_string: String that has all species names that should be considered in aqueous phase        speciation_ratio_mol_kg: Dictionary of active species and the values of their molar ratio (mol/kg of water)        P_MPa (float, shape N): Pressures in MPa        T_K (float, shape M): Temperature in K        Returns:            rho_kgm3 (float, shape NxM): Mass density of liquid in kg/m^3            Cp_JkgK (float, shape NxM): Isobaric heat capacity of liquid in J/(kg K)            alpha_pK (float, shape NxM): Thermal expansivity of liquid in 1/K            kTherm_WmK (float, shape NxM): Thermal conductivity of liquid in W/(m K)    """    # Convert H2O label to H2O(aq) label for compatability with Supcrt database    aqueous_species_list, supcrt_speciation_ratio_mol_kg = species_convertor_compatible_with_supcrt(aqueous_species_list, speciation_ratio_mol_kg)    # Create lists of thermodynamic properties that will be of length NxM    rho_kgm3 = []    Cp_JKgK = []    alpha_pK = []    kTherm_WmK = []    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    # Go through each (P,T) combination, iterating through each P in P_MPa for a T in T_K    # To increase efficiency, set up the chemical problem before iterating through each P    for T in T_K:        # Initilialize the database        db = rkt.SupcrtDatabase("supcrt16")        # Prescribe the solution and solids        solution = rkt.AqueousPhase(aqueous_species_list)        solids = rkt.MineralPhases()        # Initialize the system        system = rkt.ChemicalSystem(db, solution, solids)        # Create constraints on equilibrium - pressure and temperature        specs = rkt.EquilibriumSpecs(system)        specs.pressure()        specs.temperature()        # Create a solver object        solver = rkt.EquilibriumSolver(specs)        # Create a chemical state and its associated properties        state = rkt.ChemicalState(system)        props = rkt.ChemicalProps(state)        # Establish equilibrium constraint values        conditions = rkt.EquilibriumConditions(specs)        conditions.temperature(T, "K")        # Now that we have created a Reaktoro instance for a given temperature, go through each pressure        for P in P_MPa:            #Establish equilibrium pressure constraint value            conditions.pressure(P, "MPa")            # Populate the state with the prescribed species at the given ratios            for ion, ratio in supcrt_speciation_ratio_mol_kg.items():                state.add(ion, ratio, "mol")            # Solve the equilibrium problem            result = solver.solve(state, conditions)            # Update the properties            props.update(state)            # Check if the equilibrium problem succeeded            if result.succeeded():                # If it did succeed, obtain the relevant aqueous only phase props                aqueous_props = props.phaseProps("AqueousPhase")                # Obtain the thermodynamic properties of the aqueous phase                rho_kg_m3 = aqueous_props.density()                Cp_J_kg_K = aqueous_props.specificHeatCapacityConstP()                # To calculate thermal coefficient, we will multiply inverse of specific volume by its                # partial derivative with respect to temperature                specific_volume_m3_kg = aqueous_props.specificVolume()                dSpecificVolumedT = aqueous_props.specificVolumeT()                thermalExpansivity_1_K = 1 / float(specific_volume_m3_kg) * float(dSpecificVolumedT)                # Append the values to the associated array                rho_kgm3.append(float(rho_kg_m3))                Cp_JKgK.append(float(Cp_J_kg_K))                alpha_pK.append(thermalExpansivity_1_K)                # Reset the state                state = rkt.ChemicalState(system)            # Otherwise, the equilibrium problem failed so we need to handle it accordingly            # NEED TO COME UP WITH SELF CONSISTENT WAY TO HANDLE REAKTORO DIVERGENCE ERRORS            else:                # Log to the user that the computation was unsuccessful (useful for debugging as well)                log.warning(                    f"Unsuccessful computation at: {props.pressure() / 1e+6} MPa and {props.temperature()} K.\n"                    f"The temperature and pressure may be out of bounds, thus we will extrapolate this value from the previous ones. STILL NEEDS TO BE IMPLEMENTED")                # Reset the state                state = rkt.ChemicalState(system)                # NEED TO COME UP WTIH SELF CONSISTENT WAY TO EXTRAPOLATE THESE VALUES                # ONE IDEA: FIND CLOSEST TEMP THAT RKT CAN SOLVE PROBLEM FOR AND FIND PROPERTIES AT THESE VALUES                rho_kgm3.append(1000)                Cp_JKgK.append(0.0)                alpha_pK.append(0.0)    # Turn the list into an array and transpose it into a format identical to what PP does, where pressure is in row and temperature is in columns    rho_kgm3 = np.array(rho_kgm3).reshape(len(T_K), len(P_MPa)).T    Cp_JKgK = np.array(Cp_JKgK).reshape(len(T_K), len(P_MPa)).T    alpha_pK = np.array(alpha_pK).reshape(len(T_K), len(P_MPa)).T    # Thermal conductivity not provided by RKT, for now return constant thermal conductivity of water    kTherm_WmK = np.zeros_like(alpha_pK) + Constants.kThermWater_WmK    # Return the thermodynamic properties    return rho_kgm3, Cp_JKgK, alpha_pK, kTherm_WmKdef species_convertor_compatible_with_supcrt(aqueous_species_string, speciation_ratio_mol_kg):    """    Converts aqueous species string and speciation ratio dictionary into formats compatible with supcrt. Namely, in phreeqc the liquid phase of H2O    is labeled "H2O", whereas in supcrt it requires "H2O(aq)". Thus, converts "H2O" in the string and speciation ratio dictionary to "H2O(aq)".    Importantly, since speciation_ratio_mol_kg is a dictionary, we must make a deep copy before editing so as to not disturb the original dictionary, which    will still be used by the phreeqc database in the phase change function.    Args:        aqueous_species_string: String that has all species names that should be considered in aqueous phase        speciation_ratio_mol_kg: Dictionary of active species and the values of their molar ratio (mol/kg of water)    Returns:        aqueous_species_string: Adapted string that has all species names in format compatible with supcrt        supcrt_speciation_ratio_mol_kg: Deep copy of dictionary that has species names in format compatible with supcrt    """    # Check if "H2O" is in the string (and thus dictionary), indicating it is not compatible with supcrt    if "H2O" in aqueous_species_string:        # Change "H2O" to "H2O(aq) in the string        aqueous_species_list = aqueous_species_string.replace("H2O", "H2O(aq)")        # Since python passes dictionary by reference, need to make deep copy to preserve original dictionary        supcrt_speciation_ratio_mol_kg = copy.deepcopy(speciation_ratio_mol_kg)        # Now change the "H2O" key in the dictionary to "H2O(aq)"        supcrt_speciation_ratio_mol_kg["H2O(aq)"] = supcrt_speciation_ratio_mol_kg.pop("H2O")        # Return the string and adapted dictionary        return aqueous_species_list, supcrt_speciation_ratio_mol_kg    else:        # If "H2O" is not in the string (and thus dictionary), then just return them back        return aqueous_species_string, speciation_ratio_mol_kgclass RktPhase():    """    Class that can find the phase of a given speciation over a range of temperatures and pressures    """    def __init__(self, aqueous_species_list, speciation_ratio_mol_kg, TMin_K, TMax_K, PMin_MPa, PMax_MPa):        """        Initialize the RKtPhase() object with the mininum and maximum T (in K) and P (in MPa) and speciation info.        Importantly, find the associated freezing temperature at PMax_MPa, which will be used if any input pressure is >= PMax_MPa, since        Rkt won't be able to solve that problem.        """        self.aqueous_species_list = aqueous_species_list        self.speciation_ratio_mol_kg = speciation_ratio_mol_kg        self.TMin_K = TMin_K        self.TMax_K = TMax_K        self.PMin_MPa = PMin_MPa        self.PMax_MPa = PMax_MPa        # Obtain the freezing temperature at PMax - this will drasticaslly decrease runtime when this object is called since        # rkt_t_freeze won't have to be called each time        self.TFreezing_At_PMax = rkt_t_freeze(aqueous_species_list, speciation_ratio_mol_kg, self.PMax_MPa, TMin_K, TMax_K, "frezchem.dat")    def __call__(self, P_MPa, T_K, grid = False):        """        Call the ice_freezing function for the given input P_MPa and T_K coordinates.        Importantly, ice_frrezing assumes P_MPa and T_K are the same size and correspond to one another (coordinate pairs),        so we get them into that format if they are not already.        Args:            P_MPa: Array of pressures            T_K: Array of temperatures            grid: Whether or not they need to be made into a coordinate grid        Returns:            The associated phases of the solution for the input pressure and temperatures        """        # Convert a 0-d numpy array (only holds one value) into a 1d array so it is compatible with ice_freezing function        if np.size(P_MPa) == 1:            P_MPa = np.atleast_1d(P_MPa)        if np.size(T_K) == 1:            T_K = np.atleast_1d(T_K)        # SHOULD ADD GRID IMPLEMENTATION HERE        # Similar approach to SF, where we specify the P_MPa and T_K at equilibrium, and ice_freezing function returns        # if ice has formed or not at given temperature and pressure, with 1 indicating the phase is solid and 0 indicating the phase is liquid        return ice_freezing(self.aqueous_species_list, self.speciation_ratio_mol_kg, P_MPa, T_K, self.TMin_K, self.TMax_K, self.TFreezing_At_PMax).astype(np.int_)        # Alternative used approaches that did not work are listed below (CAN BE DELETED IN FUTURE)        '''        # IDENTICAL APPROACH TO GSW        # 1. Subtract the freezing temperature from the input temperature        # 2. Compare to zero -- if we are below the freezing temp, it's ice I, above, liquid        # 3. Cast the above comparison (True if less than Tfreeze, False if greater) to int,        #       so that we get 1 if we are below the freezing temp and 0 if above.        return (T_K - rkt_t_freeze(self.aqueous_species_list, self.speciation_ratio_mol_kg, P_MPa, self.TMin_K,                            self.TMax_K) < 0).astype(np.int_)        Alternative approach is to obtain Pfreezing from the prescribed T_K, since the way PlanetProfile obtains the Melting EOS,        this class will not have access to the hydrosphere TMin and TMax which I am using to constrain Reaktoro's search.        Instead, can use the constraints of         PMin to PMax to find the freezing pressure for a prescribed temperature via Reaktoro.        return (P_MPa - rkt_p_freeze(self.aqueous_species_list, self.speciation_ratio_mol_kg, T_K, self.PMin_MPa,                            self.PMax_MPa) < 0).astype(np.int_)        '''def SpeciesParser(species_string_with_ratios):    '''    Converts the provided String of species and their molar ratios into formats necessary for Reaktoro. Namely, creates    a String of all the species in the list and a dictionary with 'active' species that are added to solution (the observer species are    automatically generated to be 1e-16 moles in the solution by Reaktoro). It also returns the w_ppt of the solution. If any of the species do not exist in the database Reaktoro is implementing    (namely frezchem), this method raises an error that the species does not exist.     Parameters     ----------     species_string_with_ratios: String of all the species that should be considered in aqueous phase and their corresponding molar ratios.        For example, "Cl-: 19.076, Na+: 5.002, Ca2+: 0.0"     Returns     -------     aqueous_species_string: String that has all species names that should be considered in aqueous phase     speciation_ratio_mol_kg: Dictionary of active species and the values of their molar ratio (mol/kg of water)    '''    db = rkt.PhreeqcDatabase("frezchem.dat")    aqueous_species_string = ""    speciation_ratio_mol_kg = {}    # Go through each species and corresponding ratio_mol_kg and add to corresponding lists    for species_with_ratio in species_string_with_ratios.split(", "):        species, ratio_mol_kg = species_with_ratio.split(": ")        # Ensure that species is in frezchem database and if not then raise error        try:            db.species(species)        except:            raise ValueError(f'{species} does not exist in the frezchem database. Check that it is spelled correctly')        aqueous_species_string = aqueous_species_string + species + " "        # Check if the species is active (amount > 0 mol) and if so, add it to the dictionary        if (float(ratio_mol_kg) > 0):            speciation_ratio_mol_kg[species] = float(ratio_mol_kg)    # Check if water is in the aqueous species string and dictionary and if not, add it, ensuring to update the weight to be 1kg    if not "H2O" in aqueous_species_string:        aqueous_species_string = aqueous_species_string + "H2O "    speciation_ratio_mol_kg.update({"H2O": float(1/rkt.waterMolarMass)}) #Adds mols of H2O for 1kg of total solution    # Return the species string and dictionary (remove the trailing white space from the String as well with rstrip())    return aqueous_species_string.rstrip(" "), speciation_ratio_mol_kgdef ice_freezing(aqueous_species_list, speciation_ratio_mol_kg, P_MPa, T_K, TMin_K, TMax_K, TFreezing_At_PMax, significant_threshold = 1e-14):    """     Calculates whether ice is freezing at the given temperature and pressure. Utilizes the reaktoro framework to     constrain the equilibrium position at the prescribed pressure and temperature with the given composition,     and determines if ice has formed at a significant threshold of 1e-14, therefore calculating the phase of the solution     and returning true if the phase is ice and false if the phase is liquid.     Parameters     ----------     aqueous_species_list: aqueous species in reaction. Should be formatted in one long string with a space in between each species     speciation_ratio_mol_kg: the ratio of species in the aqueous solution in mol/kg of water. Should be a dictionary     with the species as the key and its ratio as its value.     P_MPa (float, shape N): the desired equilibrium freezing pressure(s) in an array of size N.     T_K (float, shape N): the desired equilibrium freezing temperature(s) in an array of size N.     significant_threshold: the amount of moles of ice present for H2O to be considered in solid phase. Default is 1e-14 moles.     Returns     -------     ice_present (boolean, shape N): an array of true and falses that indicate whether for prescribed P_MPa and T_K coordiantes        if there is ice present at significant threshold (default of 1e-14)     """    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    # Create list that holds boolean values of whether ice is present    ice_present = []    # Go through each (P,T) combination, where we assume that P_MPa and T_K are same size and correspond to one another    for i in range(np.size(P_MPa)):        P = P_MPa[i]       # Ensure that the pressure is below 100MPa, the maximum pressure that Phreeqc can handle        if P < 100:            # Obtain associated temperature            T = T_K[i]            # Obtain the corresponding database (either frezchem or core10, depending on the temperature)            database = ""            ice_name = ""            if 200 < T and T < 298.15:                database = "frezchem.dat"  # Frezchem is compatible from 200 to 298.15K                ice_name = "Ice(s)"            else:                database = "core10.dat"                ice_name = "Ice"            # Initialize the database            db = rkt.PhreeqcDatabase(database)            # Prescribe the solution            solution = rkt.AqueousPhase(aqueous_species_list)            # Obtain all related solid phases            solids = rkt.MineralPhases()            # Initialize the system            system = rkt.ChemicalSystem(db, solution, solids)            # Create constraints on equilibrium - pressure and temperature            specs = rkt.EquilibriumSpecs(system)            specs.pressure()            specs.temperature()            # Create a solver object            solver = rkt.EquilibriumSolver(specs)            # Create a chemical state and its associated properties            state = rkt.ChemicalState(system)            props = rkt.ChemicalProps(state)            conditions = rkt.EquilibriumConditions(specs)            conditions.pressure(P, "MPa")            conditions.temperature(T, "K")            # Populate the state with the prescribed species at the given ratios            for ion, ratio in speciation_ratio_mol_kg.items():                state.add(ion, ratio, "mol")            # Solve the equilibrium problem            result = solver.solve(state, conditions)            # Update the properties            props.update(state)            # Check if the equilibrium problem succeeded            if result.succeeded():                # If so, obtain the total amount of solid H2O at equilibrium in moles                ice_amount = props.speciesAmount(ice_name)                # If the amount of solid H2O at equilibrium is > the significant threshold, then append true to the list, otherwise append false                ice_present.append(ice_amount > significant_threshold)                # Reset the state                state = rkt.ChemicalState(system)            # Otherwise, the equilibrium problem failed so we need to handle it accordingly            else:                # Warn the user about the failed equilibrium (good for debugging)                log.warning(                    f"Unsuccessful computation at: {props.pressure() / 1e+6} MPa and {props.temperature()} K.\n"                    f"The temperature and pressure may be out of bounds, but sometimes Reaktoro fails to converge on specific values even within bounds.\n"                    f"Will take an alternative approach of rerunning the equilibrium calculation by determining the temperature at which ice begins to forms at the given pressure and composition,\n"                    f"and if this temperature is below the freezing temperature then we will assume the state is solid, and if the temperature is above the freezing temperature then we will assume the state is liquid.")                # Instead, we will find the associated freezing temperature with the prescribed pressure and compare that freezing temperature to T                freezing_temperature = rkt_t_freeze(aqueous_species_list, speciation_ratio_mol_kg, P, TMin_K, TMax_K, database, significant_threshold)                # If T is <= the freezing temperature for the given pressure, then we will assume ice is also present at this temperature and append True to list                # Otherwise, if T > the freezing temperature, we will assume ice is not present and append False to list                ice_present.append(T <= freezing_temperature) # If T <= freezing_temperature, then we assume ice is present                # Reset the state                state = rkt.ChemicalState(system)        # If Pressure is >= PMax, Reaktoro is at its limits of computation and will likely fail. Thus, we can compare T_K[i] to        # the freezing temperature at P_Max, which we have already saved. This alternative approach will yield good results in addition to        # drastically improving runtime by not needing to create a Reaktoro object each instance that PMax is reached.        else:            ice_present.append(T_K[i] < TFreezing_At_PMax)    # Convert the ice_present list into an array (of shape N) and return    ice_present = np.array(ice_present)    return ice_presentdef ices_phases_amount_mol(props: rkt.ChemicalProps):    '''    Helper equilibirum constraint function to constrain the total amount of moles of all ices in the current state using its associated properties. Function is used in    the ice constraint for rkt_p_freeze().    '''    # Get name of H2O ice (either Ice(s) for frezchem or Ice for core10.dat)    ice_name = ""    try:        # Check if ice is labeled as "Ice(s)" in database (core10.dat labeling)        props.system().database().species("Ice(s)")        ice_name = "Ice(s)"    except Exception as e:        # If exception is thrown, then we are using frezchem.dat database and ice_name should be "Ice"        ice_name = "Ice"    # Return the amount of solid H2O in the state, given by moles    return props.speciesAmount(ice_name)def rkt_t_freeze(aqueous_species_list, speciation_ratio_mol_kg, P_MPa, TMin_K, TMax_K, database, signifant_threshold = 1e-14):    """     Calculates the temperature at which the prescribed aqueous solution freezes. Utilizes the reaktoro framework to     constrain the equilibrium position at the prescribed pressure, the lower and upper limits of temperature (in MPa),     and the total amount of ice at a significant threshold of 1e-14, therefore calculating and returning the     temperature (within the range) at which ice begins to form.     Parameters     ----------     aqueous_species_list: aqueous species in reaction. Should be formatted in one long string with a space in between each species     speciation_ratio_mol_kg: the ratio of species in the aqueous solution in mol/kg of water. Should be a dictionary     with the species as the key and its ratio as its value.     P_MPa: the desired equilibrium freezing pressure(s).     TMin_K: the lower limit of temperature that Reaktoro should query over     TMax_K: the upper limit of temperature that Reaktoro should query over     database: the Phreeqc database to be using in this calculation (either frezchem.dat or core10.dat)     significant_threshold: the amount of moles of ice present for H2O to be considered in solid phase. Default is 1e-14 moles.     Returns     -------     t_freezing_K: the temperature at which the solution begins to freeze.     """    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    # Initialize the database with the corersponding database    db = rkt.PhreeqcDatabase(database)    # Prescribe the solution    solution = rkt.AqueousPhase(aqueous_species_list)    # Obtain all related solid phases    solids = rkt.MineralPhases()    # Initialize the system    system = rkt.ChemicalSystem(db, solution, solids)    # Create constraints on equilibrium and establish that temperature is unknown    specs = rkt.EquilibriumSpecs(system)    specs.pressure()    specs.unknownTemperature()    # Create equilibrium constraint on the phase amount of ices to significant threshold    # This constraint will allow Reaktoro to query for the pressure at which ice begins to form at the prescribed pressure    idx_ice_phase = specs.addInput("IP")    ices_phase_constraint = rkt.EquationConstraint()    ices_phase_constraint.id = "icePhaseAmountConstraint"    ices_phase_constraint.fn = lambda props, w: ices_phases_amount_mol(props) - w[idx_ice_phase]    specs.addConstraint(ices_phase_constraint)    # Create a solver object    solver = rkt.EquilibriumSolver(specs)    # Create a chemical state and its associated properties    state = rkt.ChemicalState(system)    props = rkt.ChemicalProps(state)    # Prescribe the equilibrium constraints on pressure at P_MPa, ice phase amount at the significant threshold,    # and the temperatures to query over    conditions = rkt.EquilibriumConditions(specs)    conditions.pressure(P_MPa, "MPa")    conditions.set("IP", signifant_threshold)    conditions.setLowerBoundTemperature(TMin_K, "K")    conditions.setUpperBoundTemperature(TMax_K, "K")    # Populate the state with the prescribed species at the given ratios    for ion, ratio in speciation_ratio_mol_kg.items():        state.add(ion, ratio, "mol")    # Solve the equilibrium problem    result = solver.solve(state, conditions)    # Update the properties    props.update(state)    # Obtain the equilibrium temperature    equilibrium_temperature = props.temperature()    # Return the equilibrium temperature    return equilibrium_temperature# -----------------------------------# Functions below are not utilized, but may be useful at some point in future# -----------------------------------def rkt_p_freeze(aqueous_species_list, speciation_ratio_mol_kg, T_K, PLower_MPa, PUpper_MPa):    """    Calculates the pressure at which the prescribed aqueous solution freezes. Utilizes the reaktoro framework to    constrain the equilibrium position at the prescribed T_K, the lower and upper limits of pressure (in MPa),    and the total amount of ice at a significant threshold of 1e-14, therefore calculating and returning the    pressure (within the range) at which ice begins to form.    Parameters    ----------    aqueous_species_list: aqueous species in reaction. Should be formatted in one long string with a space in between each species    speciation_ratio_mol_kg: the ratio of species in the aqueous solution in mol/kg of water. Should be a dictionary    with the species as the key and its ratio as its value.    T_freezing_K: the desired equilibrium freezing temperature    PLower_MPa: the lower limit of pressure that Reaktoro should query over    PUpper_MPa: the upper limit of pressure that Reaktoro should query over    Returns    -------    p_freezing_MPa: the pressure at which the solution begins to freeze    """    # Initilialize the database with frezchem    db = rkt.PhreeqcDatabase("frezchem.dat")    # Prescribe the solution    solution = rkt.AqueousPhase(aqueous_species_list)    # Obtain all related solid phases    solids = rkt.MineralPhases("Ice(s)")    # Initialize the system    system = rkt.ChemicalSystem(db, solution, solids)    # Create constraints on equilibrium - temperature and significant threshold for ice    specs = rkt.EquilibriumSpecs(system)    specs.temperature()    # Create equilibrium constraint on the phase amount of ices to 1e-14    # This constraint will allow Reaktoro to query for the pressure at which ice begins to form at the prescribed temperature    ice_phase_final = 1e-14 # Establish the desired equilibrium amount of total ices (1e-14 moles)    idx_ice_phase = specs.addInput("IP")    ices_phase_constraint = rkt.EquationConstraint()    ices_phase_constraint.id = "icePhaseAmountConstraint"    ices_phase_constraint.fn = lambda props, w: ices_phases_amount_mol(props) - w[idx_ice_phase]    specs.addConstraint(ices_phase_constraint)    # Create a solver object    solver = rkt.EquilibriumSolver(specs)    # Create a chemical state and its associated properties    state = rkt.ChemicalState(system)    props = rkt.ChemicalProps(state)    # Check if pressure is a list and if so, then query over each pressure and obtain the associated bottom temperature    p_freezing_MPa = []    # Use a for loop to go through each temperature    for temperature in T_K:        # Prescribe the equilibrium constraints on temperature at T_K, ice phase amount at the significant threshold,        # and the pressures to query over        conditions = rkt.EquilibriumConditions(specs)        conditions.temperature(temperature, "K")        conditions.set("IP", ice_phase_final)        conditions.setLowerBoundPressure(PLower_MPa, "MPa")        conditions.setUpperBoundPressure(PUpper_MPa, "MPa")        # Populate the state with the prescribed species at the given ratios        for ion, ratio in speciation_ratio_mol_kg.items():            state.add(ion, ratio, "mol")        # Add a kg of water to the state        # Solve the equilibrium problem        result = solver.solve(state, conditions)        # Update the properties        props.update(state)        # Check if the result failed, and if it did, then it is likely because the freezing pressure could not be found given the pressure constraints.        # Thus, check if the state has reached the pressure limits so append the constraint and add this        if result.failed():            # Check if we have reached the upper pressure constraint            if props.pressure() == PUpper_MPa:                print("Have reached the upper pressure constraint of ", props.pressure, "MPa. Consider raising PMax_MPa")            print("Returning zero as the bottom pressure. Should be handled accordingly.")            p_freezing_MPa.append(np.float_(0))            # Reset the state            state = rkt.ChemicalState(system)        else:            # Otherwise, return the equilibrium state's pressure, which is the bottom pressure (converted to MPa from Pa)            equilibrium_pressure = props.pressure() / 1e+6            print(f"{equilibrium_pressure}MPa at {temperature} K")            p_freezing_MPa.append(equilibrium_pressure)            # Reset the state            state = rkt.ChemicalState(system)    # Convert the p_temperature_K list into an array and return    p_freezing_MPa = np.array(p_freezing_MPa)    return p_freezing_MPadef lowest_temperature_allowed(aqueous_species_list, speciation_ratio_mol_kg, P_MPa, T_K):    """ Find the lowest temperature at which Rkt can find equilibrium.    Args:        aqueous_species_list:        speciation_ratio_mol_kg:        P_MPa:        T_K:    Returns:    """    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    # Go through each (P,T) combination, iterating through each P in P_MPa for a T in T_K    # To increase efficiency, set up the chemical problem before iterating through each P    # Initilialize the database    db = rkt.SupcrtDatabase("supcrt16")    # Prescribe the solution and solids    solution = rkt.AqueousPhase(aqueous_species_list)    solids = rkt.MineralPhases()    # Initialize the system    system = rkt.ChemicalSystem(db, solution, solids)    # Create constraints on equilibrium - pressure and temperature    specs = rkt.EquilibriumSpecs(system)    specs.pressure()    specs.temperature()    # Create a solver object    solver = rkt.EquilibriumSolver(specs)    # Create a chemical state    state = rkt.ChemicalState(system)    for ion, ratio in speciation_ratio_mol_kg.items():        state.add(ion, ratio, "mol")    # Establish equilibrium constraint values    conditions = rkt.EquilibriumConditions(specs)    conditions.temperature(T_K, "K")    conditions.pressure(P_MPa, "MPa")    # Solve the equilibrium problem    result = solver.solve(state, conditions)    # If result succeeded, return true, otherwise returnt false    if result.succeeded():        return 0.5    else:        return -0.5def database_to_use(T_K):    """ Decides between frezchem.dat and core10.dat database to use according to the temperature.        As per Comparison of thermodynamic data files for PHREEQC (Lu et. al 2022):            frezchem.dat: −73–25°C at 1 bar            core10.dat: 0.01–100°C at 1bar, 100–300°C along P_Sat (water vapor saturation pressure)        Currently, frezchem will be utilized for 200K<T<298.15T, and dat10 for T>=298.15.    Args:        T_K: The temperature to determine between frezchem.dat and core10.dat    Returns:        database: the database to use according to the temperature criteria above        ice_name: the name of H2O solid state for the database, which has different labels for the databases.    """    if 200 < T_K and T_K < 298.15:        database = "frezchem.dat"  # Frezchem is compatible from 200 to 298.15K        ice_name = "Ice(s)"    else:        database = "core10.dat"        ice_name = "Ice"    return database, ice_name