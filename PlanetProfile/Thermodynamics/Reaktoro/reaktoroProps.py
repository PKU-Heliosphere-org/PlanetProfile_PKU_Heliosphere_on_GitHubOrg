from PlanetProfile.Thermodynamics.Reaktoro.sigmaElectricMcCleskey2012 import elecCondMcCleskey2012from PlanetProfile.Thermodynamics.Reaktoro.reaktoroPropsHelperFunctions import *from PlanetProfile import _ROOTfrom PlanetProfile.Utilities.defineStructs import Constants, EOSlist, ReaktoroStructfrom hdf5storage import loadmat, savematfrom PlanetProfile.Utilities.DataManip import ResetNearestExtrap, ReturnConstantPTwfrom collections.abc import Iterablefrom scipy.interpolate import RegularGridInterpolator# Assign loggerlog = logging.getLogger('PlanetProfile')# Obtain correction splinetemperature_correction_spline = TemperatureCorrectionSplineGenerator()# Obtain variable that will hold Reaktoro ParamsReaktoroParams = ReaktoroStruct(_ROOT)def FileSetupFromConfig(CustomSolutionParams):    """ Check CustomSolutionConfig inputs are valid, set file paths, and save global reference to object so Rkt file can use    """    # Ensure frezchem database is valid    for file_name in os.listdir(ReaktoroParams.databasePath):        if file_name == CustomSolutionParams.FREZCHEM_DATABASE:            break    else:        log.warning("Input frezchem database does not match any of the available saved files.\nCheck that the input is properly spelled and has .dat at end. Using default frezchem.dat file")        CustomSolutionParams.FREZCHEM_DATABASE = "frezchem.dat"    # Check the unit is 'g' or 'mol' (g - grams, mol - mols)    if not CustomSolutionParams.SPECIES_CONCENTRATION_UNIT == "g" and not CustomSolutionParams.SPECIES_CONCENTRATION_UNIT  == "mol":        log.warning("Input species concentration unit is not valid. Check that it is either g or mol. Using g as default")        CustomSolutionParams.SPECIES_CONCENTRATION_UNIT = "g"    # Internally save the relevant CustomSolutionParameters to ReaktoroParams object so they can be used by Reaktoro file    for attr, value in CustomSolutionParams.__dict__.items():        setattr(ReaktoroParams, attr, value)    # Set paths for Reaktoro Params object    ReaktoroParams.setPaths()    return CustomSolutionParamsdef RktProps(EOS_lookup_label, aqueous_species_string, speciation_ratio_per_kg, P_MPa, T_K, EXTRAP):    fn_RktProps = RktPropsLookup(EOS_lookup_label, aqueous_species_string, speciation_ratio_per_kg)    if not EXTRAP:        newP_MPa, newT_K = ResetNearestExtrap(P_MPa, T_K, fn_RktProps.Pmin, fn_RktProps.Pmax,                                                    fn_RktProps.Tmin, fn_RktProps.Tmax)        if (not np.all(newP_MPa == P_MPa)) or (not np.all(newT_K == T_K)):            log.warning('Extrapolation is disabled for ocean fluids, and input EOS P and/or T ' +                        'extend beyond the EOS properties lookup table limits of [Pmin, Pmax] = ' +                        f'{fn_RktProps.Pmin}, {fn_RktProps.Pmax} MPa and [Tmin, Tmax] = ' +                        f'{fn_RktProps.Tmin}, {fn_RktProps.Tmax} K.')            P_MPa = np.unique(newP_MPa)            T_K = np.unique(newT_K)        # Ensure that T_K has at least 5 values in it in order to make rectbivariatespline        if np.size(T_K) < 5:            T_K = np.linspace(T_K[0] - 0.05, T_K[0] + 0.05, 5)    evalPts = fn_RktProps.fn_evalPts(P_MPa, T_K)    nPs = np.size(P_MPa)    # Interpolate the input data to get the values corresponding to the current ocean comp,    # then get the property values for the input (P,T) pairs and reshape to how they need    # to be formatted for use in the ocean EOS.    rho_kgm3 = np.reshape(fn_RktProps.fn_rho_kgm3(evalPts), (nPs,-1))    Cp_JkgK = np.reshape(fn_RktProps.fn_Cp_JkgK(evalPts), (nPs,-1))    alpha_pK = np.reshape(fn_RktProps.fn_alpha_pK(evalPts), (nPs,-1))    kTherm_WmK = fn_RktProps.fn_kTherm_WmK(P_MPa, T_K, 0)    return P_MPa, T_K, rho_kgm3, Cp_JkgK, alpha_pK, kTherm_WmKclass RktPropsLookup:    def __init__(self, EOS_lookup_label, aqueous_species_string, speciation_ratio_per_kg):        self.fLookup = os.path.join(ReaktoroParams.rktPath, 'CustomSolutionLookupTables', f'props_{EOS_lookup_label}.mat')        if self.fLookup in EOSlist.loaded.keys():            log.debug(f'EOS properties lookup table with label {EOS_lookup_label} already loaded.')            self.fn_rho_kgm3, self.fn_Cp_JkgK, self.fn_alpha_pK, self.fn_kTherm_WmK, self.fn_evalPts = EOSlist.loaded[self.fLookup]            self.Pmin, self.Pmax, self.Tmin, self.Tmax = EOSlist.ranges[self.fLookup]        else:            if os.path.exists(self.fLookup):                fRktProps = loadmat(self.fLookup)                TRkt_K = fRktProps['T_K']                PRkt_MPa = fRktProps['P_MPa']                self.fn_rho_kgm3 = RegularGridInterpolator((PRkt_MPa, TRkt_K), fRktProps['rho'], method = 'cubic', bounds_error = False, fill_value = None)                self.fn_Cp_JkgK = RegularGridInterpolator((PRkt_MPa, TRkt_K), fRktProps['Cp'], method = 'cubic', bounds_error = False, fill_value = None)                self.fn_alpha_pK = RegularGridInterpolator((PRkt_MPa, TRkt_K), fRktProps['alpha'], method = 'cubic', bounds_error = False, fill_value = None)                self.fn_kTherm_WmK = ReturnConstantPTw(const=Constants.kThermWater_WmK)                self.Pmin = np.min(PRkt_MPa)                self.Pmax = np.max(PRkt_MPa)                self.EOSdeltaP = np.maximum(np.round(np.mean(np.diff(PRkt_MPa)), 2), 0.001)                self.Tmin = np.min(TRkt_K)                self.Tmax = np.max(TRkt_K)                self.EOSdeltaT = np.maximum(np.round(np.mean(np.diff(TRkt_K)), 2), 0.001)            else:                log.warning(f'EOS properties lookup table with label {EOS_lookup_label} does not exist, so we will generate a property EOS.\n'                            f'Namely, we will query Reaktoro to find the lower and upper pressure and temperature limits and create EOS with input pressure step and temperature step in CustomSolution config.')                self.Tmin, self.Tmax, self.Pmin, self.Pmax = self.PropsConstraintFinder(aqueous_species_string, speciation_ratio_per_kg)                log.warning(f'Input EOS will span from [Pmin, Pmax] = {self.Pmin}, {self.Pmax} MPa by a step of {ReaktoroParams.EOS_deltaP}\n'                            f'and [Tmin, Tmax] = {self.Tmin}, {self.Tmax} K by a step of {ReaktoroParams.EOS_deltaT}.')                TRkt_K = np.arange(self.Tmin, self.Tmax, ReaktoroParams.EOS_deltaT)                PRkt_MPa = np.arange(self.Pmin, self.Pmax, ReaktoroParams.EOS_deltaP)                rho_kgm3, Cp_JKgK, alpha_pK, VP_kms = self.RktProps(aqueous_species_string, speciation_ratio_per_kg, PRkt_MPa, TRkt_K, "supcrt16")                # Calculate bulk modulus from sound speed                KS_GPa = rho_kgm3 * VP_kms ** 2 * 1e-3                # Load properties into a dictionary and save to a .mat file                RKtProps_Dictionary = {'T_K': TRkt_K, 'P_MPa': PRkt_MPa, 'rho': rho_kgm3, 'Cp': Cp_JKgK, 'alpha': alpha_pK, 'VP': VP_kms, 'KS': KS_GPa}                savemat(self.fLookup, RKtProps_Dictionary)                # Load properties into variables so that they can be used                self.fn_rho_kgm3 = RegularGridInterpolator((PRkt_MPa, TRkt_K), rho_kgm3, method = 'cubic', bounds_error = False, fill_value = None)                self.fn_Cp_JkgK = RegularGridInterpolator((PRkt_MPa, TRkt_K), Cp_JKgK, method = 'cubic', bounds_error = False, fill_value = None)                self.fn_alpha_pK = RegularGridInterpolator((PRkt_MPa, TRkt_K), alpha_pK, method = 'cubic', bounds_error = False, fill_value = None)                self.fn_kTherm_WmK = ReturnConstantPTw(const=Constants.kThermWater_WmK)                self.Pmin = np.min(PRkt_MPa)                self.Pmax = np.max(PRkt_MPa)                self.EOSdeltaP = ReaktoroParams.EOS_deltaP                self.Tmin = np.min(TRkt_K)                self.Tmax = np.max(TRkt_K)                self.EOSdeltaT = ReaktoroParams.EOS_deltaT            # Save functions to EOSlist so they can be referenced in future            EOSlist.loaded[self.fLookup] = (            self.fn_rho_kgm3, self.fn_Cp_JkgK, self.fn_alpha_pK, self.fn_kTherm_WmK, self.fn_evalPts)            EOSlist.ranges[self.fLookup] = (self.Pmin, self.Pmax, self.Tmin, self.Tmax)    def fn_evalPts(self, Pin_MPa, Tin_K):        P_MPa = ensureArray(Pin_MPa)        T_K = ensureArray(Tin_K)        out = [[P, T] for P in P_MPa for T in T_K]        return np.array(out)    def PropsConstraintFinder(self, aqueous_species_string, speciation_ratio_per_kg):        """ Finds the constraints of pressure and temperature that are compatible with both phreeqc and supcrt databases for the given solution speciation.            ~ The lower temperature limit will be dynamically set by supcrt as equilibrium for this database can only be found starting at temperature of ~240K.            ~ The upper temperature is statically set to 400K            ~ The lower pressure limit will by statistically set to 0.1 MPa            ~ The upper pressure limit will be set to 200 MPa, the maximum pressure before high pressure ices            Returns adjusted pressure and temperature ranges with the found constraints. This approach is similar to MgSO4 solution, however we take advantage            of RKt's dynamic ability to find chemical equilibrium different depending on the solution, rather than hard coding in constraints.        Args:            P_MPa (shape N): Array of pressures that will be queried over in future functions, but needs to be checked to ensure the pressures are within ranges compatible with Rkt.            T_K (shape M): Array of temperatures that will be queried over in future functions, but needs to be checked to ensure the temperatures are within ranges compatible with Rkt.            aqueous_species_list: String that has all species names that should be considered in aqueous phase            speciation_ratio_mol_kg: Dictionary of active species and the values of their molar ratio (mol/kg of water)        Returns:            P_MPa (AT MOST shape N): Adjusted array that only has values from initial P_MPa that are compatible with RKt.            P (AT MOST shape M): Adjusted array that only has values from initial T_K that are compatible with RKt.        """        # Dynamically find lower Tmin_K that supcrt can converge at        Tmin_K = Constants.SupcrtTmin_K        Tmin_K = temperature_constraint(Tmin_K, aqueous_species_string, speciation_ratio_per_kg, "supcrt16")        Tmax_K = Constants.SupcrtTmax_K        Pmin_MPa = Constants.SupcrtPmin_MPa        Pmax_MPa = Constants.PminHPices_MPa        return Tmin_K, Tmax_K, Pmin_MPa, Pmax_MPa    def RktProps(self, aqueous_species_list, speciation_ratio_mol_kg, P_MPa, T_K, database="supcrt16"):        """ Determine density rho, heat capacity Cp, thermal expansivity alpha,            and thermal conductivity kTherm as functions of pressure P and            temperature T for the provided solution species list and corresponding molarity ratios.            Implements Reaktoro Supcrt database to find these thermal properties at equilibrium for the prescribed pressure and temperature.            Importantly, if any thermal properties cannot be found due to equilibrium divergence, we perform a linear interpolation on these values, however            this outcome is HIGHLY UNLIKELY since we have found constraints that are compatible with Rkt, and user is warned if this does occur.        Args:            aqueous_species_string: String that has all species names that should be considered in aqueous phase            speciation_ratio_mol_kg: Dictionary of active species and the values of their molar ratio (mol/kg of water)            P_MPa (float, shape N): Pressures in MPa            T_K (float, shape M): Temperature in K            Returns:                rho_kgm3 (float, shape NxM): Mass density of liquid in kg/m^3                Cp_JkgK (float, shape NxM): Isobaric heat capacity of liquid in J/(kg K)                alpha_pK (float, shape NxM): Thermal expansivity of liquid in 1/K                kTherm_WmK (float, shape NxM): Thermal conductivity of liquid in W/(m K)        """        # Convert H2O label to H2O(aq) label for compatability with Supcrt database        aqueous_species_list, speciation_ratio_mol_kg = species_convertor_compatible_with_supcrt(aqueous_species_list,                                                                                                 speciation_ratio_mol_kg,                                                                                                 Constants.PhreeqcToSupcrtNames)        # Create lists of thermodynamic properties that will be of length NxM        rho_kgm3 = []        Cp_JKgK = []        alpha_pK = []        Vp_kms = []        # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.        rkt.Warnings.disable(906)        # Create Reaktoro objects        db, system, state, conditions, solver, props = SupcrtGenerator(aqueous_species_list, speciation_ratio_mol_kg,                                                                       ReaktoroParams.SPECIES_CONCENTRATION_UNIT,                                                                       database)        # Create P_MPa and T_K into a meshgrid, which will improve runtime while iterating over the combinations        P_MPa, T_K = np.meshgrid(P_MPa, T_K, indexing='ij')        # Create a nditer iterator        it = np.nditer([P_MPa, T_K], flags=['multi_index'])        # Go through each P, T combination        for P, T in it:            P = float(P)            T = float(T)            conditions.temperature(T, "K")            # Establish equilibrium pressure constraint value            conditions.pressure(P, "MPa")            # Solve the equilibrium problem            result = solver.solve(state, conditions)            # Update the properties            props.update(state)            # Check if the equilibrium problem succeeded            if result.succeeded():                # If it did succeed, obtain the relevant aqueous only phase props                aqueous_props = props.phaseProps("AqueousPhase")                # Obtain the thermodynamic properties of the aqueous phase                rho_kg_m3 = aqueous_props.density()                Cp_J_kg_K = aqueous_props.specificHeatCapacityConstP()                # To calculate thermal coefficient, we will multiply inverse of specific volume by its                # partial derivative with respect to temperature                specific_volume_m3_kg = aqueous_props.specificVolume()                dSpecificVolumedT = aqueous_props.specificVolumeT()                thermalExpansivity_1_K = 1 / float(specific_volume_m3_kg) * float(dSpecificVolumedT)                # To calculate sound speed, obtain specific volume and pressure derivative of specific volume                specific_volume_m3_kg = float(aqueous_props.specificVolume())                pressure_derivative_specific_volume = float(aqueous_props.specificVolumeP())                # Calculate commpressibility factor, multiplying negative inverse of specific volume by pressure derivative of specific volume                k_compressibility = -(1 / specific_volume_m3_kg) * pressure_derivative_specific_volume                # Calculate sound speed, multiplying k by density and taking the product to the -0.5                c_m_s = (rho_kg_m3 * k_compressibility) ** (-0.5)                # Convert to km/s                c_km_s = c_m_s / 1000                # Append the values to the associated array                rho_kgm3.append(float(rho_kg_m3))                Cp_JKgK.append(float(Cp_J_kg_K))                alpha_pK.append(float(thermalExpansivity_1_K))                Vp_kms.append(float(c_km_s))                # Reset the state                state = reset_state(system, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)            # Otherwise, the equilibrium problem failed so we need to handle it accordingly            # THIS IS VERY UNLIKELY SINCE WE HAVE ESTABLISHED CONSTRAINTS OF TEMPERATURE AND PRESSURE THAT SHOULD WORK WITH SUPCRT            else:                # Log to the user that the computation was unsuccessful and that missed value will be extrapolated                log.warning(                    f"Unsuccessful computation at: {props.pressure() / 1e+6} MPa and {props.temperature()} K.\n"                    f"The temperature and pressure may be out of bounds, thus we will linearly extrapolate this value from previous ones using a 2d interopolation")                # Reset the state                state = reset_state(system, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)                # Append zeros, which will be modified later                rho_kgm3.append(np.nan)                Cp_JKgK.append(np.nan)                alpha_pK.append(np.nan)                Vp_kms.append(np.nan)        # Turn the list into an array of shape NxM        rho_kgm3 = np.array(rho_kgm3).reshape(P_MPa.shape)        Cp_JKgK = np.array(Cp_JKgK).reshape(P_MPa.shape)        alpha_pK = np.array(alpha_pK).reshape(P_MPa.shape)        Vp_kms = np.array(Vp_kms).reshape(P_MPa.shape)        # In the case that any properties could not be calculated, we must linearly interpolate these        # THIS IS HIGHLY UNLIKELY SINCE WE HAVE FOUND CONSTRAINTS COMPATIBLE WITH RKT, BUT JUST IN CASE THIS IS IMPLEMENTED (has not been rigorously tested)        if np.sum(np.isnan(rho_kgm3)) > 0:            rho_kgm3, Cp_JKgK, alpha_pK, Vp_kms = interpolation_2d(P_MPa, [rho_kgm3, Cp_JKgK, alpha_pK, Vp_kms])        # Return the thermodynamic properties        return rho_kgm3, Cp_JKgK, alpha_pK, Vp_kmsdef ensureArray(var):    if isinstance(var, Iterable):        return var    else:        return np.array([var])def SpeciesParser(species_string_with_ratios):    '''    Converts the provided String of species and their molar ratios into formats necessary for Reaktoro. Namely, creates    a String of all the species in the list and a dictionary with 'active' species that are added to solution (the observer species are    automatically generated to be 1e-16 moles in the solution by Reaktoro). It also returns the w_ppt of the solution. If any of the species do not exist in the database Reaktoro is implementing    (namely the frezchem database), this method raises an error that the species does not exist.     Parameters     ----------     species_string_with_ratios: String of all the species that should be considered in aqueous phase and their corresponding molar ratios.        For example, "Cl-: 19.076, Na+: 5.002, Ca2+: 0.0"     Returns     -------     aqueous_species_string: String that has all species names that should be considered in aqueous phase     speciation_ratio_per_kg: Dictionary of active species and the values of their molar ratio (g/kg or mol/kg of water)     EOS_lookup_label: EOS table lookup label    '''    # Initialize the Phreeqc database with frezchem    db = rkt.PhreeqcDatabase.fromFile(ReaktoroParams.frezchemPath)    # Create a new string that will hold all the aqueous species in a format compatible with Reaktoro    aqueous_species_string = ""    # Create a new string that will be the EOS lookup table label, starting with customLabel    EOS_lookup_label = ""    # Create a new dictionary that will hold all the aqueous species with a specified amount to add in a format compatible with Reaktoro    speciation_ratio_per_kg = {}    # Go through each species and corresponding ratio_per_kg and add to corresponding lists    for species_with_ratio in species_string_with_ratios.split(", "):        species, ratio_per_kg = species_with_ratio.split(": ")        # Ensure that species is in frezchem database and if not then raise error        try:            db.species(species)        except:            raise ValueError(f'{species} does not exist in the Phreeqc database. Check that it is entered correctly in the Planet.ocean.species')        # Add species to string        aqueous_species_string = aqueous_species_string + species + " "        # Check if the species is active (amount > 0 mol) and if so, add it to the dictionary        if (float(ratio_per_kg) > 0):            speciation_ratio_per_kg[species] = float(ratio_per_kg)        # Add species and concentration to customLabel        EOS_lookup_label = EOS_lookup_label + f'_{species}-{ratio_per_kg}'    # Check if water is in the aqueous species string and dictionary and if not, add it, ensuring to update the weight to be 1kg    if not "H2O" in aqueous_species_string:        aqueous_species_string = aqueous_species_string + "H2O "    # Ensure H2O amount is a mol or g equivalent of 1kg    if "mol" in ReaktoroParams.SPECIES_CONCENTRATION_UNIT:        speciation_ratio_per_kg.update({"H2O": float(1/rkt.waterMolarMass)})    elif "g" in ReaktoroParams.SPECIES_CONCENTRATION_UNIT:        speciation_ratio_per_kg.update({"H2O": 1000.0})    # Return the species string and dictionary (remove the trailing white space from the String as well with rstrip())    return aqueous_species_string.rstrip(" "), speciation_ratio_per_kg, EOS_lookup_label.strip('_')def InputConstraintFinder(P_MPa, T_K, aqueous_species_list, speciation_ratio_mol_kg):    """ Finds the constraints of pressure and temperature that are compatible with both phreeqc and supcrt databases for the given solution speciation.        Namely, the temperature lower limit will be set by supcrt as equilibrium for this database can only be found starting at temperature of ~240K.        Moreover, the upper pressure limit will be set to 200MPa since Reaktoro doesn't have any high pressure ices.        As of now, the temperature upper limit and pressure lower limit are not adjusted, since Reaktoro seems to be compatible with high temperatures and low pressures of        PlanetProfile so no need to adjust.        Returns adjusted pressure and temperature ranges with the found constraints. This approach is similar to MgSO4 solution, however we take advantage        of RKt's dynamic ability to find chemical equilibrium different depending on the solution, rather than hard coding in constraints.    Args:        P_MPa (shape N): Array of pressures that will be queried over in future functions, but needs to be checked to ensure the pressures are within ranges compatible with Rkt.        T_K (shape M): Array of temperatures that will be queried over in future functions, but needs to be checked to ensure the temperatures are within ranges compatible with Rkt.        aqueous_species_list: String that has all species names that should be considered in aqueous phase        speciation_ratio_mol_kg: Dictionary of active species and the values of their molar ratio (mol/kg of water)    Returns:        P_MPa (AT MOST shape N): Adjusted array that only has values from initial P_MPa that are compatible with RKt.        P (AT MOST shape M): Adjusted array that only has values from initial T_K that are compatible with RKt.    """    # Save dP and dT    dP = P_MPa[1]-P_MPa[0]    dT = T_K[1]-T_K[0]    # Save the lower limit of pressure of the pressure range, which may be adjusted since Reaktoro needs valid pressures above 0MPa to find equilibrium    P_initial_lower_MPa = P_MPa[0]    # If the initial lower limit of pressure is 0MPa, then reset to an arbitrarily small 0.0001MPa  so that Reaktoro can calculate equilibrium    if P_initial_lower_MPa <= 0:        P_initial_lower_MPa = 0.0001    P_new_lower_MPa = P_initial_lower_MPa    # Save the upper limit of temperature of the temperature range, which will not be adjusted since core10 and supcrt are compatible well beyond range utilized by PP    T_upper_K = T_K[np.size(T_K) - 1]    # Save the initial upper limit of pressure of the pressure range    P_initial_upper_MPa = P_MPa[np.size(P_MPa) - 1]    # If the initial upper limit is above 200 MPa (the minimum for high pressure ices), then reset to 200 since we know Rkt doesn't have high pressure ices    if  P_initial_upper_MPa > Constants.PminHPices_MPa:        P_initial_upper_MPa = Constants.PminHPices_MPa    P_new_upper_MPa = P_initial_upper_MPa    # Save the initial lower limit of temperature of the temperature range, which may be adjusted since supcrt can only go to about ~240K depending on solution    T_initial_lower_K = T_K[0]    # If the initial lower limit is below Constants.TminRkt_K (240K) then reset to that value since we know supcrt can't go below this temperature    if T_initial_lower_K < Constants.TminRkt_K:        T_initial_lower_K = Constants.TminRkt_K    # Find the new lower temperature limit, which may be above 240K    T_new_lower_K = temperature_constraint(T_initial_lower_K, aqueous_species_list, speciation_ratio_mol_kg, "supcrt16")    # Adjust the pressure and temperature ranges with the new constraints    newP_MPa, newT_K = ResetNearestExtrap(P_MPa, T_K, P_new_lower_MPa, P_new_upper_MPa,                                          T_new_lower_K, T_upper_K)    # If the pressure and/or temperature ranges were adjusted, then log that they were changed to the user    if (not np.all(newP_MPa == P_MPa)) or (not np.all(newT_K == T_K)):        log.warning(f'Input EOS P and/or T of [Pmin, Pmax] = {P_new_lower_MPa}, {P_MPa[np.size(P_MPa) - 1]} MPa and [Tmin, Tmax] = {T_K[0]}, {T_upper_K}\n' +                    'extended beyond the Rkt compatibility limits, which will be adjusted to a compatible range of\n' +                    f'[Pmin, Pmax] = {P_new_lower_MPa}, {P_new_upper_MPa} MPa and [Tmin, Tmax] = {T_new_lower_K}, {T_upper_K} K.')    # Save only the unique values in the array and return    P_MPa = np.unique(newP_MPa)    T_K = np.unique(newT_K)    # Ensure that P_MPa and T_K have at least 10 values in it in order to make rectbivariatespline    if np.size(P_MPa) < 10:        P_MPa = np.linspace(P_MPa[0], P_MPa[-1]+dP, 10)    if np.size(T_K) < 11:        T_K = np.linspace(T_K[0], T_K[-1]+dT, 11)    return P_MPa, T_Kclass RktPhase:    """    Class that can find the phase of a given speciation over a range of temperatures and pressures    """    def __init__(self, aqueous_species_list, speciation_ratio_mol_kg, TMin_K, TMax_K, PMin_MPa, PMax_MPa):        """        Initialize the RKtPhase() object with the minimum and maximum T (in K) and P (in MPa) and speciation info.        Importantly, find the associated freezing temperature at PMax_MPa, which will be used if any input pressure is >= PMax_MPa, since        Rkt won't be able to solve that problem.        """        self.aqueous_species_list = aqueous_species_list        self.speciation_ratio_mol_kg = speciation_ratio_mol_kg        self.TMin_K = TMin_K        self.TMax_K = TMax_K        self.PMin_MPa = PMin_MPa        # Create both frezchem and core Reaktoro systems that can be utilized later on        self.frezchem = PhreeqcGeneratorForChemicalConstraint(self.aqueous_species_list, self.speciation_ratio_mol_kg,ReaktoroParams.SPECIES_CONCENTRATION_UNIT,  ReaktoroParams.frezchemPath)        self.spline_for_pressures_above_100_MPa, self.PMax_MPa = Frezchem_Spline_Generator(self.aqueous_species_list, self.speciation_ratio_mol_kg)        self.calculated_freezing_temperatures = {}    def __call__(self, P_MPa, T_K, grid = False):        """        Call the ice_freezing function for the given input P_MPa and T_K coordinates.        Importantly, ice_frrezing assumes P_MPa and T_K are the same size and correspond to one another (coordinate pairs),        so we get them into that format if they are not already.        Args:            P_MPa: Array of pressures            T_K: Array of temperatures            grid: Whether or not they need to be made into a coordinate grid        Returns:            The associated phases of the solution for the input pressure and temperatures        """        if not grid:            np.array(P_MPa)            np.array(T_K)        freezing_temperatures = rkt_t_freeze(self.aqueous_species_list, self.speciation_ratio_mol_kg, P_MPa, self.frezchem, self.PMax_MPa, self.spline_for_pressures_above_100_MPa, self.calculated_freezing_temperatures)        if grid:            freezing_temperatures, T_K = np.meshgrid(freezing_temperatures, T_K, indexing='ij')        return (T_K < freezing_temperatures).astype(np.int_)def rkt_t_freeze(aqueous_species_list, speciation_ratio_mol_kg, P_MPa, frezchem, PMax_MPa, freezing_temperature_spline, calculated_freezing_temperatures, TMin_K = 220, TMax_K = 300, significant_threshold = 0.1):    """     Calculates the temperature at which the prescribed aqueous solution freezes. Utilizes the reaktoro framework to     constrain the equilibrium position at the prescribed pressure, the lower and upper limits of temperature (in K),     and the total amount of ice at a significant threshold of 1e-14, therefore calculating and returning the     temperature (within the range) at which ice begins to form.     Parameters     ----------     aqueous_species_list: aqueous species in reaction. Should be formatted in one long string with a space in between each species     speciation_ratio_mol_kg: the ratio of species in the aqueous solution in mol/kg of water. Should be a dictionary     with the species as the key and its ratio as its value.     P_MPa: the desired equilibrium freezing pressure(s).     TMin_K: the lower limit of temperature that Reaktoro should query over     TMax_K: the upper limit of temperature that Reaktoro should query over     significant_threshold: the amount of moles of ice present for H2O to be considered in solid phase. Default is 1e-14 moles.     Returns     -------     t_freezing_K: the temperature at which the solution begins to freeze.     """    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    # rkt.Warnings.disable(906)    # Create list that holds boolean values of whether ice is present    freezing_temperatures = []    db, system, state, conditions, solver, props = frezchem    state = rkt.ChemicalState(state)    # Create an iterator to go through P_MPa    it = np.nditer([P_MPa])    conditions.set("IP", significant_threshold)    conditions.setLowerBoundTemperature(TMin_K, "K")    conditions.setUpperBoundTemperature(TMax_K, "K")    for P in it:        P = float(P)        # Adjust Pressure        if P in calculated_freezing_temperatures.keys():            equilibrium_temperature = calculated_freezing_temperatures[P]            freezing_temperatures.append(equilibrium_temperature)            continue        # Check that pressure is below PMax_MPa, the maximum pressure constraint calculated previously        if P <= PMax_MPa:            # Specify equilibrium constraints            conditions.pressure(P, "MPa")            # Solve the equilibrium problem            result = solver.solve(state, conditions)            # Update the properties            props.update(state)            # Obtain the equilibrium temperature            equilibrium_temperature = props.temperature()            # Correct the equilibrium temperature using the temperature correction spline            equilibrium_temperature = equilibrium_temperature + temperature_correction_spline(P)            # Check if the result succeeded            if result.succeeded():                state = reset_state(system, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)            # If the result failed, we will use spline            else:                log.warning(f"While attempting to find bottom freezing temperature for pressure of {P} MPa, \n"                            +f"Reaktoro was unable to find a temperature within range of {TMin_K} K and {TMax_K}.\n"                            +f"Instead, we will use a spline of freezing temperatures that we generated for this EOS to find the associated freezing temperature.")                equilibrium_temperature = freezing_temperature_spline(P)                state = reset_state(system, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)        # If Pressure is >= PMax, Reaktoro is at its limits of computation and will likely fail. Thus, we utilize our spline approximation of freezing temperatures        # over a range of pressures that we are confident that Frezchem works at and find the associated freezing temperature at the given pressure.        # If the temperature we are querying over is less than that freezing temperature, then we assume its ice, otherwise we assume its liquid        else:            equilibrium_temperature = freezing_temperature_spline(P)        freezing_temperatures.append(equilibrium_temperature)        calculated_freezing_temperatures[P] = equilibrium_temperature    # Return the equilibrium temperature    return np.array(freezing_temperatures)def Frezchem_Spline_Generator(aqueous_species_list, speciation_ratio_mol_kg, data_points = 30, significant_threshold = 0.1):    P_MPa = np.linspace(0.1, 100, data_points)    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    TMin_K = 220    TMax_K = 300    # Create Reaktoro objects    db, system, state, conditions, solver, props = PhreeqcGeneratorForChemicalConstraint(aqueous_species_list, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT, ReaktoroParams.frezchemPath)    # Create freezing temperatures list and indices of pressures to remove, if necessary    freezing_temperatures = []    indices_to_remove = []    for index, P in enumerate(P_MPa):        # Specify equilibrium constraints        conditions.pressure(P, "MPa")        conditions.set("IP", significant_threshold)        conditions.setLowerBoundTemperature(TMin_K, "K")        conditions.setUpperBoundTemperature(TMax_K, "K")        # Solve the equilibrium problem        result = solver.solve(state, conditions)        # Update the properties        props.update(state)        # Obtain the equilibrium temperature        equilibrium_temperature = props.temperature()        # Correct equilibrium temperature with correction spline        corrected_temperature = float(equilibrium_temperature) + temperature_correction_spline(P)        # Check if the result succeeded        if result.succeeded():            freezing_temperatures.append(corrected_temperature)            state = reset_state(system, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)        # If the result failed, then do not include this in list of freezing temperatures and remove from pressure list to avoid its use in creating spline        else:            indices_to_remove.append(index)            state = reset_state(system, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)    # Remove pressures that failed to find equilibrium    if len(indices_to_remove) > 5:        log.warning("Reaktoro had a difficult time finding convergence of species composition to generate spline over range of [0.1, 100] MPa. Be warned that results are being extrapolated far beyond Frezchem's ability.")    P_MPa = np.delete(P_MPa, indices_to_remove)    # Convert freezing_temperatures to array    freezing_temperatures = np.array(freezing_temperatures)    # Create b-spline    spline = interpolate.make_interp_spline(P_MPa, freezing_temperatures, k = 2)    # Find highest pressure at which Frezchem could find freezing temperature for given composition    max_pressure = P_MPa[-1]    # Return spline and max pressure    return spline, max_pressureclass RktSeismic():    def __init__(self, aqueous_species_list, speciation_ratio_mol_kg, TMin_K, TMax_K, PMin_MPa, PMax_MPa):        """        Initialize the RKtSeismic() object with the minimum and maximum T (in K) and P (in MPa) and speciation info.        """        self.aqueous_species_list = aqueous_species_list        self.speciation_ratio_mol_kg = speciation_ratio_mol_kg        self.TMin_K = TMin_K        self.TMax_K = TMax_K        self.PMin_MPa = PMin_MPa        self.PMax_MPa = PMax_MPa    def __call__(self, P_MPa, T_K, grid = False):        """        Finds the sound speed in km/s and bulk modulus in GPa for the input of P_MPa and T_K        Args:            P_MPa (float, Shape N): Array of pressures            T_K (float, Shape N): Array of temperatures            grid: Whether or not they need to be made into a coordinate grid        Returns:            VP_kms (float, Shape N): Corresponding sound speeds in km/s            KS_GPa (float, Shape N): Corresponding bulk modulus in GPa        """        if grid:            P_MPa, T_K = np.meshgrid(P_MPa, T_K, indexing='ij')        else:            P_MPa = np.array(P_MPa)            T_K = np.array(T_K)            if (np.size(P_MPa) == 0 or np.size(T_K) == 0):                # If input is empty, return empty array                return np.array([])            elif ((np.size(P_MPa) != np.size(T_K)) and not (np.size(P_MPa)==1 or np.size(T_K)==1)):                # If arrays are different lengths, they are probably meant to get a 2D output                P_MPa, T_K = np.meshgrid(P_MPa, T_K, indexing='ij')        # Finds the sound speed and associated densities for the given pressure and temperature inputs        VP_kms, rho_kgm3 = seismic_calculations(self.aqueous_species_list, self.speciation_ratio_mol_kg, P_MPa, T_K)        # Calculates the bulk modulus from its relaiontship with sound speed and density        KS_GPa = rho_kgm3 * VP_kms**2*1e-3 # 1e-3 because (km/s)^2 * (kg/m^3) gives units of MPa, so 1e-3 to convert to GPa        # Return sound speed and bulk modulus        return VP_kms, KS_GPadef seismic_calculations(aqueous_species_list, speciation_ratio_mol_kg, P_MPa, T_K, database = "supcrt16"):    """    Calculates the sound speed and densities of the aqueous phase of the solution for the input pressure and temperatures,    utilizing the thermodynamic properties provided by the supcrt database at equilibrium.    Args:        aqueous_species_list: aqueous species in reaction. Should be formatted in one long string with a space in between each species        speciation_ratio_mol_kg: the ratio of species in the aqueous solution in mol/kg of water. Should be a dictionary with the species as the key and its ratio as its value.        P_MPa (float, shape N): the desired equilibrium freezing pressure(s) in an array of size N.        T_K (float, shape N): the desired equilibrium freezing temperature(s) in an array of size N.    Returns:        sound_speeds (float, shape N): Associated aqueous sound speeds in km/s        densities (float, shape N): Associated aqueous densities in km/s    """    # Convert H2O label to H2O(aq) label for compatability with Supcrt database    aqueous_species_list, speciation_ratio_mol_kg = species_convertor_compatible_with_supcrt(        aqueous_species_list, speciation_ratio_mol_kg, Constants.PhreeqcToSupcrtNames)    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    # Create list that will become array that will hold sound speeds    sound_speeds = []    # Create list that will become array taht holds corresponding aqueous densities    densities = []    # Create Reaktoro objects    db, system, state, conditions, solver, props = SupcrtGenerator(aqueous_species_list,                                                                                  speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT, database)    # Create an iterator to go through P_MPa and T_K    it = np.nditer([P_MPa, T_K], flags =['multi_index'])    # Go through each (P,T) combination, where we assume that P_MPa and T_K are same size and correspond to one another    for P, T in it:        P = float(P)        T = float(T)        conditions.temperature(T, "K")        conditions.pressure(P, "MPa")        # Solve the equilibrium problem        result = solver.solve(state, conditions)        # Update the properties        props.update(state)        # Check if the equilibrium problem succeeded        if result.succeeded():            # If it did succeed, obtain the relevant aqueous only phase props            aqueous_props = props.phaseProps("AqueousPhase")            # Obtain density, specific volume, and pressure derivative of specific volume            density_kg_m3 = float(aqueous_props.density())            specific_volume_m3_kg = float(aqueous_props.specificVolume())            pressure_derivative_specific_volume = float(aqueous_props.specificVolumeP())            # Calculate commpressibility factor, multiplying negative inverse of specific volume by pressure derivative of specific volume            k_compressibility = -(1/specific_volume_m3_kg)*pressure_derivative_specific_volume            # Calculate sound speed, multiplying k by density and taking the product to the -0.5            c_m_s = (density_kg_m3*k_compressibility)**(-0.5)            # Convert to km/s            c_km_s = c_m_s / 1000            # Append to lists            sound_speeds.append(c_km_s)            densities.append(density_kg_m3)            # Reset the state            state = reset_state(system, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)        # If equilibrium did not succeed, then we will linearly interpolate these values        # THIS IS VERY UNLIKELY SINCE WE ARE CALCULATING SEISMIC VALUES FOR OCEAN LAYER WHICH HAS ALREADY BEEN CALCULATED BY RKT, SO VALUES SHOULD BE WITHIN RANGE OF RKT        else:            # For now, just append np.nan and we will handle later            sound_speeds.append(np.nan)            densities.append(np.nan)            # Reset the state            state = reset_state(system, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)    # Convert lists to arrays    sound_speeds = np.array(sound_speeds).reshape(P_MPa.shape)    densities = np.array(densities).reshape(P_MPa.shape)    # Check if any values are np.nan, which indicates they were not found in chemical equilibrium    # THIS IS VERY UNLIKELY SINCE RKT SHOULD BE ABLE TO HANDLE INPUT P AND T RANGE, HOWEVER FOR SELF-CONSISTENCY WE ADD THIS IN CASE    if np.sum(np.isnan(sound_speeds)) > 0:        sound_speeds, densities = interpolation_1d(P_MPa, [sound_speeds, densities])        log.warning("Performed 1d linear interpolation on missing seismic properties")    return sound_speeds, densitiesclass RktConduct():    def __init__(self, aqueous_species_list, speciation_ratio_mol_kg):        """        Initialize the RKtConduct() object and parse the aqueous species list into a format compatible with elecCondMcClevskey2012()        """        self.ions = McClevskyIonParser(speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)    def __call__(self, P_MPa, T_K, grid = False):        """        Finds electrical conductivity for given ions. Currently does not adjust for pressure.        Args:            Array of pressures            T_K (float, Shape N): Array of temperatures            grid: Whether or not they need to be made into a coordinate grid        Returns:            VP_kms (float, Shape N): Corresponding sound speeds in km/s            KS_GPa (float, Shape N): Corresponding bulk modulus in GPa        """        if grid:            P_MPa, T_K = np.meshgrid(P_MPa, T_K, indexing='ij')        else:            P_MPa = np.array(P_MPa)            T_K = np.array(T_K)            if (np.size(P_MPa) == 0 or np.size(T_K) == 0):                # If input is empty, return empty array                return np.array([])            elif ((np.size(P_MPa) != np.size(T_K)) and not (np.size(P_MPa)==1 or np.size(T_K)==1)):                # If arrays are different lengths, they are probably meant to get a 2D output                P_MPa, T_K = np.meshgrid(P_MPa, T_K, indexing='ij')        T_C = T_K - Constants.T0        ions = elecCondMcCleskey2012(P_MPa, T_C, self.ions)        sigma_data = ions['sigma_Sm']        return sigma_dataclass Reaktoro_Hydro_Species_Generator():    def __init__(self, aqueous_species_list, speciation_ratio_mol_kg):        # Convert H2O label to H2O(aq) label for compatability with Supcrt database        self.aqueous_species_list, self.speciation_ratio_mol_kg = species_convertor_compatible_with_supcrt(aqueous_species_list, speciation_ratio_mol_kg, Constants.PhreeqcToSupcrtNames)        self.supcrt = SupcrtGenerator(self.aqueous_species_list, self.speciation_ratio_mol_kg,ReaktoroParams.SPECIES_CONCENTRATION_UNIT, "supcrt16")    def __call__(self, P_MPa, T_K, grid = False):        if grid:            P_MPa, T_K = np.meshgrid(P_MPa, T_K, indexing='ij')        else:            P_MPa = np.array(P_MPa)            T_K = np.array(T_K)            if (np.size(P_MPa) == 0 or np.size(T_K) == 0):                # If input is empty, return empty array                return np.array([])            elif ((np.size(P_MPa) != np.size(T_K)) and not (np.size(P_MPa) == 1 or np.size(T_K) == 1)):                # If arrays are different lengths, they are probably meant to get a 2D output                P_MPa, T_K = np.meshgrid(P_MPa, T_K, indexing='ij')        return species_at_equilibrium(P_MPa, T_K, self.supcrt, self.speciation_ratio_mol_kg)def species_at_equilibrium(P_MPa, T_K, supcrt, speciation_ratio_mol_kg):    db, system, state, conditions, solver, props = supcrt    df = panda_df_generator(system)    try:        aprops = rkt.AqueousProps(state)    except:        aprops = None    state = rkt.ChemicalState(state)    # Create an iterator to go through P_MPa and T_K    it = np.nditer([P_MPa, T_K], flags =['multi_index'])    # Go through each (P,T) combination, where we assume that P_MPa and T_K are same size and correspond to one another    for P, T in it:        P = float(P)        T = float(T)        conditions.temperature(T, "K")        conditions.pressure(P, "MPa")        # Solve the equilibrium problem        result = solver.solve(state, conditions)        # Update the properties        props.update(state)        # Check if the equilibrium problem succeeded        if result.succeeded():            # Obtain species amount            props.update(state)            if aprops is not None:                aprops.update(state)                pH = aprops.pH()            else:                pH = np.nan            amounts = []            for speciesItem in system.species():                amounts.append(float(state.speciesAmount(speciesItem.name())))            # Obtain phase amounts            liquidAmount = [float(sum(state.speciesAmountsInPhase("AqueousPhase")))]            solidAmount = [float(sum([state.speciesAmount(solid) for solid in                                      props.indicesSpeciesInPhasesWithSolidState()]))]            # Obtain charge            charge = [np.array(float(state.charge()))]            # Create data row            data = [P] + [T] + [pH] + amounts + charge + solidAmount + liquidAmount            df.loc[len(df)] = data            state = reset_state(system, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)        else:            log.warning(f"Inability to find hydrosphere equilibrium at {P} MPa and {T} K. Will skip and go to next hydrosphere step")    return dfdef temperature_constraint(T_K, aqueous_species_list, speciation_ratio_mol_kg, database, dT = 1):    """ Find the tempearture constraint at which Reaktoro can find equilibrium for the given speciation and database. Starts at T_K and checks if rkt can find equilibrium        with a pressure of 0.1 MPa. If it cannot, then adjusts T_K by dT and tries again, continuing this process until a compatible T_K is found.        For finding the lower temperature constraint if it reaches >= 273K we stop, which Rkt should be compatible with.    Args:        T_K: Initial temperature constraint in K        aqueous_species_list: String that has all species names that should be considered in aqueous phase        speciation_ratio_mol_kg: Dictionary of active species and the values of their molar ratio (mol/kg of water)        database: Database to find temperature constraint for        dT: The amount to change T_K by if equilibrium is not achieved. Defaults to 1 (for lower constraint)    Returns:        T_K: New temperature constraint in T_K for given database.    """    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    # Initilialize the database, either being supcrt of phreeqc    if "supcrt" in database:        # Since supcrt labels "H2O(aq)", we need to adjust our species list and dictionary accordingly        aqueous_species_list, speciation_ratio_mol_kg = species_convertor_compatible_with_supcrt(            aqueous_species_list, speciation_ratio_mol_kg, Constants.PhreeqcToSupcrtNames)        db, system, state, conditions, solver, props = SupcrtGenerator(aqueous_species_list, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT, database)    else:        db, system, state, conditions, solver, props, ice_name, database_name = PhreeqcGenerator(aqueous_species_list, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT, database)    # Establish pressure constraint of 1bar    conditions.pressure(0.1, "MPa")    # Tracker variable for equilibrium being found    success = False    # While we have not found chemical equilibrium, keep iterating through    while not success:        # Establish temperature constraint at T_K        conditions.temperature(T_K, "K")        # Solve the equilibrium problem        result = solver.solve(state, conditions)        # Check if the equilibrium problem succeeded        if result.succeeded():            # If so, change success to true            success = True        # If it failed but T_K >= 273 and dT > 0, which indicates we are finding lower constraint, then set success to true since RKt should be compatible        elif T_K >= 273 and dT > 0:            log.debug("Infinite loop prevention stopped for temperature_constraint. Should likely not be occurring")            success = True        # Otherwise, equilibrium is not achieved so we should reset the state and adjust T_K by dT, and reattempt the equilibrium problem        else:            T_K += dT            state = reset_state(system, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)    # Return the adjusted T_K    return T_K"""def ice_freezing(aqueous_species_list, speciation_ratio_mol_kg, P_MPa, T_K, PMax_MPa, TMin_K, TMax_K, freezing_temperatures_spline, frezchem_database, core_database, significant_threshold = 0.1):     Calculates whether ice is freezing at the given temperature and pressure. Utilizes the reaktoro framework to     constrain the equilibrium position at the prescribed pressure and temperature with the given composition,     and determines if ice has formed at a significant threshold of 1e-14, therefore calculating the phase of the solution     and returning true if the phase is ice and false if the phase is liquid.     Parameters     ----------     aqueous_species_list: aqueous species in reaction. Should be formatted in one long string with a space in between each species     speciation_ratio_mol_kg: the ratio of species in the aqueous solution in mol/kg of water. Should be a dictionary     with the species as the key and its ratio as its value.     P_MPa (float, shape N): the desired equilibrium freezing pressure(s) in an array of size N.     T_K (float, shape N): the desired equilibrium freezing temperature(s) in an array of size N.     significant_threshold: the amount of moles of ice present for H2O to be considered in solid phase. Default is 1e-14 moles.     Returns     -------     ice_present (boolean, shape N): an array of true and falses that indicate whether for prescribed P_MPa and T_K coordinates        if there is ice present at significant threshold (default of 1e-14)    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    # Create list that holds boolean values of whether ice is present    ice_present = []    # Create an iterator to go through P_MPa and T_K    it = np.nditer([P_MPa, T_K], flags =['multi_index'])    for P, T in it:        P = float(P)        T = float(T)        # Check that pressure is below PMax_MPa, the maximum pressure constraint calculated previously        if P <= PMax_MPa:            # Determine whether to use frezchem or core database based on temperature            if T < 298.15:                db, system, state, conditions, solver, props, ice_name, database_name = frezchem_database            else:                db, system, state, conditions, solver, props, ice_name, database_name = core_database            # Specify equilibrium conditions            conditions.pressure(P, "MPa")            conditions.temperature(T, "K")            # Solve the equilibrium problem            result = solver.solve(state, conditions)            # Update the properties            props.update(state)            # Check if the equilibrium problem succeeded            if result.succeeded():                # If so, obtain the total amount of solid H2O at equilibrium in moles                ice_amount = props.speciesAmount(ice_name)                # If the amount of solid H2O at equilibrium is > the significant threshold, then append true to the list, otherwise append false                ice_present.append(ice_amount > significant_threshold)                # Reset the state                state = reset_state(system, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)            # Otherwise, the equilibrium problem failed so we need to handle it accordingly            else:                # Warn the user about the failed equilibrium (good for debugging)                log.debug(                    f"Unsuccessful computation at: {props.pressure() / 1e+6} MPa and {props.temperature()} K.\n"                    f"The temperature and pressure may be out of bounds, but sometimes Reaktoro fails to converge on specific values even within bounds.\n"                    f"Will take an alternative approach of rerunning the equilibrium calculation by determining the temperature at which ice begins to forms at the given pressure and composition,\n"                    f"and if this temperature is below the freezing temperature then we will assume the state is solid, and if the temperature is above the freezing temperature then we will assume the state is liquid.")                # Instead, we will find the associated freezing temperature with the prescribed pressure and compare that freezing temperature to T                freezing_temperature = rkt_t_freeze(aqueous_species_list, speciation_ratio_mol_kg, P, TMin_K,                                                    TMax_K, database_name, significant_threshold)                # If T is <= the freezing temperature for the given pressure, then we will assume ice is also present at this temperature and append True to list                # Otherwise, if T > the freezing temperature, we will assume ice is not present and append False to list                ice_present.append(T <= freezing_temperature)  # If T <= freezing_temperature, then we assume ice is present                # Reset the state                state = reset_state(system, speciation_ratio_mol_kg, ReaktoroParams.SPECIES_CONCENTRATION_UNIT)        # If Pressure is >= PMax, Reaktoro is at its limits of computation and will likely fail. Thus, we utilize our spline approximation of freezing temperatures        # over a range of pressures that we are confident that Frezchem works at and find the associated freezing temperature at the given pressure.        # If the temperature we are querying over is less than that freezing temperature, then we assume its ice, otherwise we assume its liquid        else:            TFreezing_At_P = freezing_temperatures_spline(P)            ice_present.append(T < TFreezing_At_P)    # Convert the ice_present list into an array (of shape N) and return    ice_present = np.reshape(ice_present, P_MPa.shape)    return ice_present """